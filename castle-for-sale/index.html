<html style="font-family: Lora;"><head>
    <title>project</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0">
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAXUlEQVQ4jWNkQANfHl77jy6GDHjktRiR+SgcQpqxGcKETcGRY+sZjhxbj5M/ElxACmBB5uByJj4w8F7AawC+0IeBQeYFYmIBXQ0LIQWEACO6wI7lrXjDwSOyGkUPAKUpOzwONiPPAAAAAElFTkSuQmCC">
    <!-- styles-->
    <style id="base-style">:root {
    /* prevent touch gestures getting stolen by browser */
    touch-action: none;
}

/* prevent weird highlights https://stackoverflow.com/questions/21003535/ */
.no-select {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* hidden elements should be hidden regardless of their display style */
[hidden] { display: none !important; }

/* default to width/height including padding and border */
* { box-sizing: border-box; }

/* used dynamically to prevent or cancel smooth transitions */
.skip-transition { transition: none !important; }

/* make buttons inherit font */ 
button, select, option, input { font-family: inherit; font-size: inherit; }

/* clickable things should use this cursor imo */
button, a, details summary { cursor: pointer; }

/* crisp pixelart */
canvas, img {
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-crisp-edges;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}

/* nicer details */
details summary > * {
    display: inline;
}

    </style>
    <style id="core-style">:root {
    --selection-color: rgb(106, 90, 205);
    --group-color: rgba(205, 90, 119, 0.5);
    --link-color: rgba(113, 205, 90, 0.5);

    --black-text-outline: 1px 1px 1px black, -1px 1px 1px black, -1px -1px 1px black, 1px -1px 1px black;

    --card-color: white;
}

html, body {
    width: 100vw; height: 100vh;
    margin: 0; padding: 0;
}

body {
    display: flex;
    flex-direction: row;
}

#frame {
    position: relative; overflow: hidden; /* clip things */
    flex: 1;

    cursor: grab;

    background-color: rgb(183, 184, 176);
}

#scene {
    position: absolute; transform-origin: 0 0;
    width: 0; height: 0;

    /* i think this helps streamline the panning by telling the browser that it
       will be constantly moving
       https://stackoverflow.com/questions/26907265/css-will-change-how-to-use-it-how-it-works */
    /* will-change: transform; */

    /* transition: transform .1s linear; */
}

.icon-bar {
    display: flex;
    flex-direction: row;
    align-items: center;

    gap: .5em;
    margin: 0;
}

.icon-bar > .icon {
    width: 2em;
    height: 2em;
    grid-row: 1;

    padding: 0;
    
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;
}

.target {
    position: absolute;
    z-index: -1;

    /* tiny curve on corners */
    border-radius: .5em;
    background: black;

    opacity: 50%;
}

.card-root.selected {
    box-shadow: 0 0 0 8px var(--selection-color);
}

/* main toolbar */
#toolbar {
    position: absolute;
    right: 0; bottom: 0;
    
    font-size: 1.5em;
    padding: .5em;

    display: flex;
    flex-direction: row;
}

/* main toolbar buttons */
#toolbar > .icon {
    background: rgb(240, 240, 240);
    border: 1px solid black;
    border-radius: 100%;
    cursor: pointer;
}

.toolbar-group {
    border-radius: 100em;

    display: flex;
    flex-direction: row;
    gap: .5em;
    margin: 0;
    padding: .5em;
}

.toolbar-group > .icon {
    background: rgb(240, 240, 240);
    border: 1px solid black;
    border-radius: 100%;
    cursor: pointer;
}

#svgs > svg {
    position: absolute;
    z-index: -3;
    pointer-events: none;
    mix-blend-mode: screen;
}

svg > * {
    pointer-events: initial;
}

#svgs > svg.link {
    stroke-width: 16px;
    z-index: -2;
}

svg.link line.selection-flash {
    stroke-width: 24px;
}

#left-sidebar {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    width: 400px;

    background: var(--card-color);

    display: flex;
    flex-direction: column;
}

.editor-page > h1, h2, p {
    margin: 0;
}

.button-row > select, .button-row > input {
    flex: 1;
}

.button-row button[data-action="global-editor/card-style/new"] {
    flex: 0;
}

.settings-grid > span {
    grid-column-start: 2;
    grid-column-end: 3;
}

.settings-grid > input, .settings-grid > select {
    grid-column-start: 3;
    grid-column-end: 4;
}

.settings-grid {
    display: grid;
    
    column-gap: 1em;
    row-gap: 1em;

    grid-template-columns: auto auto minmax(0, 1fr);
}

.settings-grid .check {
    grid-column-start: 1;
    grid-column-end: 2;
    place-self: center;
}

.settings-grid input[type="checkbox"] {
    transform: scale(1.5);
}

/* CARDS */

.has-image {
    align-items: center;
}

.has-image .card-text {
    background-repeat: no-repeat;

    color: white;
    text-align: center;
    text-shadow: var(--black-text-outline);
}

.card-root {
    position: absolute;

    border-radius: 8px;
    box-shadow: 0 3px 0 var(--card-edge-color, black);
}

.card-body {
    position: relative; overflow: hidden; /* clipping */
    width: 100%; height: 100%; margin: 0;
    display: flex;
    
    background-color: var(--card-color, white);
    border-radius: inherit;
    background-size: cover;
    background-position: center;
}

.card-text {
    width: 100%;
    padding: 16px;

    color: var(--text-color, black);
    font-size: var(--text-size, initial);
    font-family: var(--text-font, inherit);
    text-align: var(--text-align, inherit);
}

.card-text > h3 {
    margin: 0;
    margin-bottom: .5em;
    font-size: 1.5em;
    font-weight: bold;
    text-align: center;
}

.card-icon-bar {
    position: absolute;
    left: 50%; bottom: 0;
    transform: translate(-50%, 50%);

    display: flex;
    justify-content: space-evenly;
    
    padding: 1em;
    margin: 0;
    width: 100%;

    font-size: 1rem;

    pointer-events: none;
}

.card-icon-bar > a {
    width: 2em;
    height: 2em;

    padding: 0;
    
    display: flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;

    pointer-events: initial;

    transition: transform .1s ease-in-out;
}

.card-icon-bar > *:hover  { transform: scale(1.5); }
.card-icon-bar > *:active { transform: scale(2);   }
/* don't animate cosmetic card icons */
.card-icon-bar > *.cosmetic { cursor: initial; transform: unset; }
/* don't respond to blank card icons */
.card-icon-bar > *.blank { pointer-events: none; transform: unset; }


#sidebar-toggle {
    position: absolute;
    left: 0; bottom: 0;
    font-size: 1.5em;
    padding: 1em;
}

    </style>
    <style id="editor-style">:root {
    font-family: sans-serif;
    font-size: 1.1em;
}

.selection-flash {
    animation-name: selection-flash;
    animation-direction: alternate;
    animation-duration: .75s;
    animation-iteration-count: infinite;
}

@keyframes selection-flash {
    0% {
        fill: black;
        stroke: black;
        border-color: black;
    }

    100% {
        fill: white;
        stroke: white;
        border-color: white;
    }
}

.resize-handle {
    position: absolute;
    width: 32px; height: 32px;
    right: -1px; bottom: -1px;

    opacity: 50%;
    display: none;
}

.resize-handle > polygon {
    cursor: se-resize;
}

.selected .resize-handle {
    display: unset;
}

body:not([data-player]) .card-root:hover .resize-handle {
    display: unset;
}

.target {
    transition: transform .1s, width .1s, height .1s;
}

.card-selection {
    position: absolute;
    left: -16px; right: -16px; top: -16px; bottom: -16px;
}

.icon.disabled {
    cursor: not-allowed;
    opacity: .5;
}

.editor-blocker {
    position: absolute;
    width: 100%; height: 100%;
    margin: 0; padding: 0;

    background-color: rgba(0, 0, 0, 25%);
}

.editor-panel {
    position: absolute;
    left: 50%; bottom: 0;
    transform: translate(-50%, 0);

    background: var(--card-color);
    pointer-events: initial;
    cursor: initial;

    width: 400px;
    max-width: 100%;
    height: 300px;
    max-height: 50%;

    display: flex;
    flex-direction: column;

    left: 0; top: 0; bottom: 0;
    width: 420px;
    height: 100%;
    max-height: none;
    max-width: none;
    transform: none;
}

#content-input {
    flex: 1;
}

.full {
    position: absolute;
    width: 100%; height: 100%;
    margin: 0; padding: 0;
}

/* generic tabbed pages styles */
.tab-bar {
    display: grid;
    grid-auto-flow: column;
    color: white;
    background:black;
}

.tab-bar > * {
    padding: 1em;
    text-align: center;
}

.tab-bar > button {
    border: none;
    background: inherit;
    color: inherit;
    text-transform: uppercase;
}

.tab-bar > *.active {
    color: black;
    background: lightblue;
}

.tab-page {
    margin: 0;
    padding: 2em;
    overflow: auto;

    flex: 1;
    display: flex;
    flex-direction: column;
}
/* end of tabbed pages styles */

.editor-page {
    padding: 1em;
    height: 100%;
    display: flex;

    flex-direction: column;
    gap: 1em;

    overflow: auto;
}

/* editor icons page styles */
#card-editor-icons {
    display: grid;

    grid-template-columns: 3em auto;
    grid-template-rows: repeat(4, 1fr);

    column-gap: 1em;
    row-gap: 1em;
}

.icon-select {
    min-width: 3em;
    text-align: center;
    font-size: 1em;

    grid-column: 1;
    grid-column-start: 1;
    grid-column-end: 2;
}

.icon-action {
    font-size: 1em;
    font-family: monospace;

    grid-column-start: 2;
    grid-column-end: 3;
}
/* end of editor icons page styles */

textarea {
    flex: 1;
    min-height: 10em;
}

.button-row {
    display: flex;
    flex-direction: row;
    align-items: stretch;
    gap: 1em;
}

.button-row > button {
    flex: 1;
    white-space: nowrap;
}

.toolbar-group[data-path="global"] {
    background: rgb(255 255 255 / 50%);
}

.toolbar-group[data-path="selection"] {
    background: var(--selection-color);
}

.toolbar-group[data-path="group"] {
    background: var(--group-color);
}

.toolbar-group[data-path="link"] {
    background: var(--link-color);
}

.toolbar-group[data-path="picker"] {
    background: var(--link-color);
}

.toolbar-group[data-path="picker"] > span {
    font-size: .75em;
    white-space: nowrap;
}

.button-list {
    display: flex;
    flex-flow: row wrap;
    align-items: flex-start;
    align-content: flex-start;
}

[data-path="card-editor/styles"] {
    flex: 1;
    min-height: 10em;
}

.card-style-settings-row {
    display: flex;
}

#card-style-fields {
    display: flex;
    flex-direction: column;
    gap: 1em;
}

#card-style-fields > h2 {
    margin: 0;
}

body[data-player] #toolbar {
    display: none;
}

.button-column {
    display: flex;
    flex-direction: column;
    align-items: stretch;
    gap: 1em;
}

/* sidebar stuff */
.sidebar-page {
    height: 100%;
    overflow: auto;

    display: flex;
    flex-direction: column;
}

.sidebar-header {
    padding: 1em;

    display: flex;
    flex-direction: column;
    gap: 1em;

    background: lightblue;
}

.sidebar-panel {
    height: 100%;
    overflow: auto;

    padding: 1em;

    display: flex;
    flex-direction: column;
    gap: 1em;
}

.sidebar-group {
    display: flex;
    flex-direction: column;
    gap: 1em;
}


.button-row .shrink {
    flex: 0;
}

    </style>
    <style id="card-styles">.style-STYLE-HEADING { --card-color: #00000040; --text-size: 30px; --text-align: center; }
.style-STYLE-HEADING .card-body { align-items: center; font-weight: bold; }
.style-STYLE-HEADING.card-root { --card-edge-color: rgba(0, 0, 0, 25%); }
.style-STYLE-GRID {  }
.style-STYLE-GRID .card-body { line-height: 1.35em; background-image: linear-gradient(gainsboro 1px, transparent 1px), linear-gradient(90deg, gainsboro 1px, transparent 1px); background-size: 1.3em 1.3em; background-position: 0.75em 0.75em; }
.style-STYLE-TERMINAL { --card-color: #000000FF; --text-font: monospace; --text-color: #00ff00ff; }
.style-EeMLC4dJM4-iD3bhd2BWk { --card-color: #ffffff7c; --text-color: #7d7d7dff; }
.style-yrKZvizTDGthzyGX_AA-X { --card-color: #0000008c; --text-font: serif; --text-size: 40px; --text-color: #b73645ff; --text-align: center; }
.style-yrKZvizTDGthzyGX_AA-X .card-text { font-variant: small-caps; }
.style-1HQnPB8fc0zpeLqCCGokQ { --card-color: #e5efd2ff; }
.style-CyZclJHl2fVSpLw53gn1Q { --card-color: #d2deefff; }
.style-vc_VZePmvF5KufvjyQGuX { --card-color: #efd6d2ff; }
.style-xlPzs0JBKNTPNxweO87oK { --card-color: #ffffff68; --text-size: 19px; --text-color: #434343ff; }</style>
    <!-- scripts-->
    <script id="database.js">/** 
 * @template T
 * @param {IDBRequest<T>} request 
 * @returns {Promise<T>}
 */
function promisfyRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

/** 
 * @param {IDBTransaction} transaction 
 * @returns {Promise}
 */
 function promisfyTransaction(transaction) {
    return new Promise((resolve, reject) => {
        transaction.oncomplete = () => resolve();
        transaction.onabort = () => reject(transaction.error);
        transaction.onerror = () => reject(transaction.error);
    });
}

async function openDatabase() {
    const request = indexedDB.open("domino2");
    request.addEventListener("upgradeneeded", () => {
        request.result.createObjectStore("projects");
        request.result.createObjectStore("projects-meta");
    });
    return promisfyRequest(request);
}

async function projectsStores(mode) {
    const db = await openDatabase();
    const transaction = db.transaction(["projects", "projects-meta"], mode);
    const projects = transaction.objectStore("projects");
    const meta = transaction.objectStore("projects-meta");
    return { transaction, projects, meta };
}

/**
 * @returns {Promise<DominoDataSaveMetadata[]>}
 */
async function listProjects() {
    const stores = await projectsStores("readonly");
    return promisfyRequest(stores.meta.getAll());
}

/**
 * @param {DominoDataProject} projectData 
 * @returns {Promise}
 */
async function saveProject(projectData, key) {
    /** @type {DominoDataSaveMetadata} */
    const meta = {
        id: projectData.details.id,
        title: projectData.details.title,
        date: (new Date()).toISOString(),
    }

    const stores = await projectsStores("readwrite");
    stores.projects.put(projectData, key);
    stores.meta.put(meta, key);
    return promisfyTransaction(stores.transaction);
}

/**
 * @param {string} key
 * @returns {Promise<DominoDataProject>}
 */
async function loadProject(key) {
    const stores = await projectsStores("readonly");
    return promisfyRequest(stores.projects.get(key));
}

/**
 * @param {string} key
 */
 async function deleteProject(key) {
    const stores = await projectsStores("readwrite");
    stores.projects.delete(key);
    stores.meta.delete(key);
    return promisfyTransaction(stores.transaction);
}

    </script>
    <script id="utility.js">'use strict'

/**
 * @typedef {Object} Vector2
 * @property {number} x
 * @property {number} y
 */

/**
 * @typedef {Object} Rect
 * @property {number} x
 * @property {number} y
 * @property {number} width
 * @property {number} height
 */

/**
 * @param {string} query 
 * @param {ParentNode} element 
 * @returns {HTMLElement}
 */
const ONE = (query, element = undefined) => (element || document).querySelector(query);
/**
 * @param {string} query 
 * @param {HTMLElement | Document} element 
 * @returns {HTMLElement[]}
 */
const ALL = (query, element = undefined) => Array.from((element || document).querySelectorAll(query));

/**
 * @template T
 * @param {T} object
 * @returns {T}
 */
const COPY = (object) => JSON.parse(JSON.stringify(object));

// async equivalent of Function constructor
const AsyncFunction = Object.getPrototypeOf(async function(){}).constructor

/**
 * @template T
 * @param {HTMLSelectElement} element 
 * @param {T[]} data 
 * @param {(data: T) => HTMLOptionElement} renderer 
 */
 function refreshDropdown(element, data, renderer) {
    const value = element.value;
    const options = data.map(renderer);
    element.replaceChildren(...options);
    element.value = value;
}

/**
 * @param {MouseEvent | Touch} event 
 * @param {HTMLElement} element 
 */
function eventToElementPixel(event, element) {
    const rect = element.getBoundingClientRect();
    return [event.clientX - rect.x, event.clientY - rect.y];
}

/** @param {Event} event */
function killEvent(event) {
    event.stopPropagation();
    event.preventDefault();
}

/**
 * @param {string} src
 * @returns {Promise<HTMLImageElement>} image
 */
async function loadImage(src) {
    return new Promise((resolve, reject) => {
        const image = document.createElement("img");
        image.addEventListener("load", () => resolve(image));
        image.src = src;
    });
}

/** @param {HTMLImageElement} image */
function imageToRendering2D(image) {
    const rendering = createRendering2D(image.naturalWidth, image.naturalHeight);
    rendering.drawImage(image, 0, 0);
    return rendering;
}

/**
 * @template {any} T
 * @param {T[]} array 
 * @param {T} value
 * @returns {boolean}
 */
function arrayDiscard(array, value) {
    const index = array.indexOf(value);
    if (index >= 0) array.splice(index, 1);
    return index >= 0;
}

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {K} tagName 
 * @param {*} attributes 
 * @param  {...(Node | string)} children 
 * @returns {HTMLElementTagNameMap[K]}
 */
function html(tagName, attributes = {}, ...children) {
    const element = /** @type {HTMLElementTagNameMap[K]} */ (document.createElement(tagName)); 
    Object.entries(attributes).forEach(([name, value]) => element.setAttribute(name, value));
    children.forEach((child) => element.append(child));
    return element;
}

/**
 * @template {keyof SVGElementTagNameMap} K
 * @param {K} tagName 
 * @param {*} attributes 
 * @param  {...SVGElement} children 
 * @returns {SVGElementTagNameMap[K]}
 */
function svg(tagName, attributes = {}, ...children) {
    const element = document.createElementNS("http://www.w3.org/2000/svg", tagName);
    Object.entries(attributes).forEach(([name, value]) => element.setAttributeNS(null, name, value));
    children.forEach((child) => element.append(child));
    return element;
}

// from https://github.com/ai/nanoid/blob/master/non-secure/index.js
const urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';
function nanoid(size = 21) {
    let id = '';
    let i = size;
    while (i--) id += urlAlphabet[(Math.random() * 64) | 0];
    return id
}

/**
 * @param {File} file 
 * @return {Promise<string>}
 */
async function textFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(/** @type {string} */ (reader.result));
        reader.readAsText(file); 
    });
}

/**
 * @param {File} file 
 * @return {Promise<string>}
 */
async function dataURLFromFile(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload = () => resolve(/** @type {string} */ (reader.result));
        reader.readAsDataURL(file); 
    });
}

/**
 * @param {string} source
 */
async function htmlFromText(source) {
    const template = document.createElement('template');
    template.innerHTML = source;
    return template.content;
}

/**
 * @param {string} text 
 */
function textToBlob(text, type = "text/plain") {
    return new Blob([text], { type });
}

/**
 * @param {string} accept 
 * @param {boolean} multiple 
 * @returns {Promise<File[]>}
 */
async function pickFiles(accept = "*", multiple = false) {
    return new Promise((resolve) => {
        const fileInput = html("input", { type: "file", accept, multiple });
        fileInput.addEventListener("change", () => resolve(Array.from(fileInput.files)));
        fileInput.click();
    });
}

function translationMatrix(translation) {
    const matrix = new DOMMatrix();
    matrix.e = translation.x;
    matrix.f = translation.y;
    return matrix;
}

/** @param {DOMMatrix} matrix */
function getMatrixTranslation(matrix) {
    return { x: matrix.e, y: matrix.f };
}

/** @param {DOMMatrix} matrix */
function getMatrixScale(matrix) {
    return { 
        x: Math.sqrt(matrix.a*matrix.a + matrix.c*matrix.c),
        y: Math.sqrt(matrix.b*matrix.b + matrix.d*matrix.d),
    };
}

/**
 * @param {number} value 
 * @param {number} min 
 * @param {number} max 
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * @param {Rect} rect 
 * @param {number} padding 
 */
function padRect(rect, padding) {
    rect.x -= padding;
    rect.y -= padding;
    rect.width += padding * 2;
    rect.height += padding * 2;
    return rect;
}

/**
 * @param {Rect} rect 
 */
function getRectCenter(rect) {
    return {
        x: rect.x + rect.width * .5,
        y: rect.y + rect.height * .5,
    }
}

/**
 * @param {Rect} rect
 * @param {{ x: number, y: number }} point 
 */
function rectContainsPoint(rect, point) {
    return point.x >= rect.x
        && point.y >= rect.y
        && point.x <  rect.x + rect.width
        && point.y <  rect.y + rect.height;
}

/**
 * @param {Rect} a 
 * @param {Rect} b 
 */
function rectsOverlap(a, b) {
    const outside = a.x + a.width  > b.x
                 || a.y + a.height > b.y
                 || a.x > b.width  + b.x
                 || a.y > b.height + b.y;

    return !outside;
}

/**
 * @param {Rect[]} rects
 * @param {Rect} fallback
 * @returns {Rect}
 */
function boundRects(rects, fallback = { x: 0, y: 0, width: 0, height: 0 }) {
    const bounds = DOMRect.fromRect(rects[0] || fallback);
    rects.forEach((rect) => {
        const { x, y, width, height } = rect;
        let [top, left, bottom, right] = [y, x, y + height, x + width];
        left = Math.min(bounds.left, left);
        top = Math.min(bounds.top, top);
        right = Math.max(bounds.right, right);
        bottom = Math.max(bounds.bottom, bottom);
        bounds.x = left;
        bounds.y = top;
        bounds.width = right - left;
        bounds.height = bottom - top;
    });
    return bounds;
}

/**
 * @param {any} item 
 * @param {any[]} array 
 */
function removeItemFromArray(item, array) {
    const index = array.indexOf(item);
    array.splice(index, 1);
}

/**
 * 
 * @param {string} original 
 * @param {string} insert 
 * @param {number} start 
 * @param {number} end 
 */
function insertText(original, insert, start, end) {
    const left = original.substring(0, start);
    const right = original.substring(end);
    return `${left}${insert}${right}`;
}

/**
 * @param {number} min 
 * @param {number} max 
 */
function range(min, max) {
    return Array.from(new Array(max-min+1), (x, i) => i + min);
}

/**
 * @param {number} min 
 * @param {number} max 
 */
function randomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1) + min);
}

/** @param {number} milliseconds */
function sleep(milliseconds) {
    return new Promise(resolve => setTimeout(resolve, milliseconds));
}

class EventEmitter {
    constructor() {
        this.listeners = {};
    }

    on(event, listener) {
        if (this.listeners[event] === undefined)
            this.listeners[event] = [];
        this.listeners[event].push(listener);
        return () => this.off(event, listener);
    }

    off(event, listener) {
        const listeners = this.listeners[event] || [];
        const index = listeners.indexOf(listener);
        if (index !== -1)
            this.listeners[event].splice(index, 1);
    }

    emit(event, ...args) {
        const listeners = this.listeners[event] || [];
        [...listeners].forEach((listener) => listener(...args));
    }

    once(event, listener) {
        const remove = this.on(event, (...args) => {
            remove();
            listener(...args);
        });
        return remove;
    }

    async wait(event, timeout = undefined) {
        return new Promise((resolve, reject) => {
            if (timeout) setTimeout(reject, timeout);
            this.once(event, resolve);
        });
    }
};

/**
 * @template {keyof WindowEventMap} K
 * @param {Window | Document | Element} element 
 * @param {K} type 
 * @param {(event: WindowEventMap[K]) => any} listener
 */
function listen(element, type, listener) {
    element.addEventListener(type, listener);
    return () => element.removeEventListener(type, listener);
}

    </script>
    <script id="htmlui.js">/**
 * @param {string} path 
 * @returns {[string, string]}
 */
function pathToRootLeaf(path) {
    const parts = path.split('/');
    const root = parts.slice(0, -1).join('/');
    const leaf = parts.slice(-1)[0];
    return [root, leaf];
}

const toggleStates = new Map();
const actionHandlers = new Map();
const pathToElement = new Map();

/**
 * @template {keyof HTMLElementTagNameMap} K
 * @param {*} path 
 * @param {K} tagName
 * @returns {HTMLElementTagNameMap[K]}
 */
function elementByPath(path, tagName) {
    /** @type {HTMLElementTagNameMap[K]} */
    const element = pathToElement.get(path);
    if (element === undefined)
        throw Error(`No element at ${path}`);
    if (element.tagName.toLowerCase() !== tagName)
        throw Error(`Element at ${path} is ${element.tagName} not ${tagName}`);
    return element;
}

function setActionHandler(action, callback) {
    actionHandlers.set(action, callback);
}

function invokeAction(action) {
    const handler = actionHandlers.get(action);
    if (handler) handler();
}

function switchTab(path) {
    elementByPath(`toggle:${path}`, "button").click();
}

function initui() {
    const toggles = ALL("[data-tab-toggle]");
    const bodies = ALL("[data-tab-body]");
    const buttons = ALL("[data-action]");

    const paths = ALL("[data-path]");
    paths.forEach((element) => {
        const path = element.getAttribute("data-path");
        pathToElement.set(path, element);
    });

    buttons.forEach((element) => {
        const action = element.getAttribute("data-action");

        element.addEventListener("click", (event) => {
            killEvent(event);
            invokeAction(action);
        });
    })

    function setGroupActiveTab(group, tab) {
        toggleStates.set(group, tab);
        toggles.forEach((element) => {
            const [group_, tab_] = pathToRootLeaf(element.getAttribute("data-tab-toggle"));
            if (group_ === group) element.classList.toggle("active", tab_ === tab);
        });
        bodies.forEach((element) => {
            const [group_, tab_] = pathToRootLeaf(element.getAttribute("data-tab-body"));
            if (group_ === group) element.hidden = (tab_ !== tab);
        });

        invokeAction(`hide:${group}`);
        invokeAction(`show:${group}/${tab}`);
    }

    toggles.forEach((element) => {
        const path = element.getAttribute("data-tab-toggle");
        pathToElement.set("toggle:" + path, element);
        const [group, tab] = pathToRootLeaf(element.getAttribute("data-tab-toggle"));
        element.addEventListener('click', (event) => {
            killEvent(event);
            setGroupActiveTab(group, tab);
        });
    });

    bodies.forEach((element) => {
        element.hidden = true;
    });

    ALL("[data-tab-default]").forEach((element) => element.click());
    
    const clicks = ['pointerdown', 'click', 'wheel', 'dblclick'];
    ALL("[data-block-clicks]").forEach((element) => {
        for (let name of clicks) {
            element.addEventListener(name, (event) => event.stopPropagation());
        }
    });
}

    </script>
    <script id="domino.js">/**
 * @typedef {Object} DominoDataCardStyle
 * @property {string} id
 * @property {string} name
 * @property {Partial<{
 *   "custom-css": string,
 *   "text-font": string,
 *   "text-color": string,
 *   "text-size": string,
 *   "text-center": string,
 *   "card-color": string,
 * }>} properties
 */

/**
 * @typedef {Object} DominoDataCardIcon
 * @property {string} icon
 * @property {string} action
 */

/**
 * @typedef {Object} DominoDataCard
 * @property {string} id
 * @property {Vector2} position
 * @property {Vector2} size
 * @property {string} text
 * @property {DominoDataCardIcon[]} icons
 * @property {string?} image
 * @property {string?} alttext
 * @property {string?} style
 */

/** 
 * @typedef {Object} DominoDataGroup
 * @property {string[]} cards
 * @property {string} color
 */

/**
 * @typedef {Object} DominoDataLink
 * @property {string} cardA
 * @property {string} cardB
 * @property {string} color
 */

/**
 * @typedef {Object} DominoDataProjectDetails
 * @property {string} id
 * @property {string} name
 * @property {string} title
 * @property {string} focus
 */

/**
 * @typedef {Object} DominoDataSaveMetadata
 * @property {string} id
 * @property {string} title
 * @property {string} date
 */

/**
 * @typedef {Partial<{
 *   "custom-css": string,
 *   "background-color": string,
 * }>} DominoDataBoardStyle
 */

/**
 * @typedef {Object} DominoDataProject
 * @property {DominoDataProjectDetails} details
 * @property {DominoDataCard[]} cards
 * @property {DominoDataGroup[]} groups
 * @property {DominoDataLink[]} links
 * @property {DominoDataCardStyle[]} cardStyles
 * @property {DominoDataBoardStyle} boardStyle
 */

    </script>
    <script id="test.js">/** @type {Set<DominoDataCard>} */
const selectedCards = new Set();
/** @type {DominoDataGroup[]} */
const selectedGroups = [];
/** @type {DominoDataLink[]} */
const selectedLinks = [];
/** @type {DominoDataCard} */
let linking;
/** @type {LinkEditor} */
let linkEditor;
/** @type {GroupEditor} */
let groupEditor;
/** @type {CardEditor} */
let cardEditor;
/** @type {DominoBoardView} */
let boardView;
/** @type {DominoProjectManager} */
let dataManager;

/** @type {CardStyleEditor} */
let cardStyleEditor;

async function test() {
    dataManager = new DominoProjectManager();
    boardView = new DominoBoardView();
    cardEditor = new CardEditor();
    linkEditor = new LinkEditor();
    groupEditor = new GroupEditor();
    cardStyleEditor = new CardStyleEditor();

    listen(scene.viewport, "dblclick", (event) => {
        if (!boardView.editable) return;

        killEvent(event);    
        const transform = scene.mouseEventToSceneTransform(event);
        transform.e -= cellWidth/2;
        transform.f -= cellHeight/2;
        gridSnap(transform);
        const position = getMatrixTranslation(transform);

        const card = {
            id: nanoid(),
            position,
            size: { x: 2, y: 2 },
            text: "new card :)",
            icons: [],
        }

        dataManager.makeCheckpoint();
        insertCard(scene, card);
        deselectAll();
        selectCard(card);
        invokeAction("global-editor/open");
        switchTab("sidebar/selection");
    });

    setActionHandler("global/undo", () => dataManager.undo());
    setActionHandler("global/redo", () => dataManager.redo());

    setActionHandler("global/view-saves", () => {
        switchTab("sidebar/board");
        cardStyleEditor.open();
        ONE("#saved-boards").open = true;
    });

    setActionHandler("project/reset", () => dataManager.reset(JSON.parse(ONE("#project-data").innerHTML)));

    setActionHandler("selection/copy-id", () => {
        const ids = Array.from(selectedCards).map((card) => card.id);
        navigator.clipboard.writeText('#' + ids.join(","));
    });
    setActionHandler("selection/group", groupSelection);
    setActionHandler("selection/link", beginLink);
    setActionHandler("selection/cancel", deselectCards);
    setActionHandler("selection/center", centerSelection);
    setActionHandler("selection/delete", () => {
        dataManager.makeCheckpoint();
        Array.from(selectedCards).forEach((card) => deleteCard(card));
    });

    setActionHandler("group/delete", deleteSelectedGroup);
    setActionHandler("group/select", selectGroupCards);

    setActionHandler("link/delete", deleteSelectedLink);
    setActionHandler("link/select", selectLinkCards);

    setActionHandler("card-editor/close", closeEditor);

    setActionHandler("picker/cancel", () => {
        linking = undefined;
        updateToolbar();
    });

    setActionHandler("global/center-focus", () => {
        const data = boardView.projectData;
        if (data.details.focus) centerCards(getCardsByIds(data.details.focus.slice(1).split(",")));
    });
    
    // image pasting
    window.addEventListener("paste", (event) => cardEditor.paste(event));

    // hotkeys
    document.addEventListener("keydown", (event) => {
        const targetTag = event.target.tagName.toLowerCase();
        const textedit = targetTag === "input" || targetTag === "textarea";

        if (event.ctrlKey && event.key === "s") {
            invokeAction("project/save");
        } else if (!textedit && event.key === "Escape") {
            deselectAll();
        } else if (!textedit && event.key === "Delete") {
            if (selectedCards.size > 0) invokeAction("selection/delete");
            if (selectedGroups.length > 0) invokeAction("group/delete");
            if (selectedLinks.length > 0) invokeAction("link/delete");
        } else if (!textedit && event.ctrlKey && event.key == "z") {
            dataManager.undo();
        } else if (!textedit && event.ctrlKey && event.key == "y") {
            dataManager.redo();
        } else {
            return;
        }

        killEvent(event);
    });
}

/** @param {DominoDataGroup} group */
function getGroupCards(group) {
    const cards = new Set(group.cards);
    return boardView.projectData.cards.filter((card) => cards.has(card.id));
}

/** @param {string[]} ids */
function getCardsByIds(ids) {
    const cards = new Set(ids);
    return boardView.projectData.cards.filter((card) => cards.has(card.id));
}

function updateToolbar() {
    const selection = selectedCards.size > 0;
    const selectedGroup = selectedGroups.length > 0;
    const selectedLink = selectedLinks.length > 0;

    elementByPath("picker", "div").hidden = !linking;

    if (selection) switchTab("sidebar/selection/cards");
    else if (selectedGroup) switchTab("sidebar/selection/group");
    else if (selectedLink) switchTab("sidebar/selection/link");
    else switchTab("sidebar/selection/none");

    // selections
    const active = selectedGroups.length > 0 ? new Set(getGroupCards(selectedGroups[0])) : selectedCards;
    boardView.cardToView.forEach((view, card) => view.setSelected(active.has(card)));

    ONE("#undo").classList.toggle("disabled", !dataManager.canUndo);
    ONE("#redo").classList.toggle("disabled", !dataManager.canRedo);
}

/** 
 * @param {PanningScene} scene
 * @param {DominoDataCard} card
 */
function insertCard(scene, card) {
    boardView.projectData.cards.push(card);
    const view = new DominoCardView(scene);
    view.setCard(card);
    boardView.cardToView.set(card, view);
    return view;
}

/** @param {DominoDataCard} card */
function deleteCard(card) {
    arrayDiscard(boardView.projectData.cards, card);

    Array.from(boardView.projectData.groups).forEach((group) => {
        if (arrayDiscard(group.cards, card.id)) refreshGroup(group);
        if (group.cards.length === 0) deleteGroup(group);
    });
    Array.from(boardView.projectData.links).forEach((link) => {
        if (link.cardA === card.id || link.cardB === card.id) {
            deleteLink(link);
        }
    });

    deselectCard(card);
    boardView.cardToView.get(card).rootElement.remove();
    boardView.cardToView.delete(card);
}

function deselectAll() {
    deselectCards();
    deselectGroup();
    deselectLink();
    updateToolbar();
}

function deselectCards() {
    selectedCards.forEach((card) => boardView.cardToView.get(card).setSelected(false));
    selectedCards.clear();

    updateToolbar();
    cardEditor.close();
}

function deselectGroup() {
    selectedGroups.forEach((group) => boardView.groupToView.get(group).setHighlight(false));
    selectedGroups.length = 0;
    updateToolbar();
    groupEditor.close();
}

function selectGroupCards() {
    getCardsByIds(selectedGroups[0].cards).forEach(selectCard);
}

function deleteSelectedGroup() {
    deleteGroup(selectedGroups.shift());
    deselectGroup();
}

function deleteGroup(group) {
    arrayDiscard(boardView.projectData.groups, group);
    boardView.groupToView.get(group).dispose();
    boardView.groupToView.delete(group);
}

function deselectLink() {
    selectedLinks.forEach((link) => boardView.linkToView.get(link).setHighlight(false));
    selectedLinks.length = 0;
    updateToolbar();
    linkEditor.close();
}

function selectLinkCards() {
    const cards = [selectedLinks[0].cardA, selectedLinks[0].cardB];
    getCardsByIds(cards).forEach(selectCard);
}

function deleteSelectedLink() {
    dataManager.makeCheckpoint();
    deleteLink(selectedLinks.shift());
    deselectLink();
}

function deleteLink(link) {
    arrayDiscard(boardView.projectData.links, link);
    boardView.linkToView.get(link).dispose();
    boardView.linkToView.delete(link);
}

function closeEditor() {
    cardEditor.close();
}

function selectCard(card) {
    if (selectedCards.size === 0) {
        switchTab("sidebar/selection");
    }

    selectedCards.add(card);
    boardView.cardToView.get(card).setSelected(true);

    deselectGroup();
    deselectLink();
    updateToolbar();

    cardEditor.openMany(Array.from(selectedCards));
}

function deselectCard(card) {
    selectedCards.delete(card);
    boardView.cardToView.get(card).setSelected(false);

    updateToolbar();
    cardEditor.openMany(Array.from(selectedCards));
}

function beginLink() {
    if (selectedCards.size !== 1) return;
    linking = Array.from(selectedCards)[0];
    updateToolbar();
}

/** @param {DominoDataCard} card */
function selectCardToggle(card) {
    if (linking) {
        const link = { cardA: linking.id, cardB: card.id, color: 'black' };
        dataManager.makeCheckpoint();
        boardView.projectData.links.push(link);
        linking = undefined;
        refreshLink(link);
        selectLinks([link]);
    } else if (selectedGroups.length > 0) {
        const group = selectedGroups[0];
        if (!arrayDiscard(group.cards, card.id)) group.cards.push(card.id);
        refreshGroup(group);
        updateToolbar();
    } else {
        if (selectedCards.has(card)) deselectCard(card);
        else selectCard(card);
    }
}

function deselectAll() {
    deselectCards();
    deselectGroup();
    deselectLink();
}

function cycleGroup() {
    const current = selectedGroups.shift();
    selectedGroups.push(current);
    boardView.groupToView.get(current).setHighlight(false);
    boardView.groupToView.get(selectedGroups[0]).setHighlight(true);
    updateToolbar();
}

/** @param {DominoDataGroup[]} groups */
function selectGroups(groups) {
    if (selectedGroups.length === 0) switchTab("sidebar/selection");

    const combined = new Set([...groups, ...selectedGroups]);
    const same = combined.size === selectedGroups.length && combined.size === groups.length;

    if (same) {
        cycleGroup();
    } else {
        const prev = selectedGroups[0];

        deselectAll();
        selectedGroups.push(...groups);
        boardView.groupToView.get(selectedGroups[0]).setHighlight(true);
        updateToolbar();
        
        if (prev === selectedGroups[0]) cycleGroup();
    }

    groupEditor.openGroups([selectedGroups[0]]);
}

function cycleLink() {
    const current = selectedLinks.shift();
    selectedLinks.push(current);
    boardView.linkToView.get(current).setHighlight(false);
    boardView.linkToView.get(selectedLinks[0]).setHighlight(true);
    updateToolbar();
}

/** @param {DominoDataLink[]} links */
function selectLinks(links) {
    if (selectedLinks.length === 0) switchTab("sidebar/selection");

    const combined = new Set([...links, ...selectedLinks]);
    const same = combined.size === selectedLinks.length && combined.size === links.length;

    if (same) {
        cycleLink();
    } else {
        const prev = selectedLinks[0];

        deselectAll();
        selectedLinks.push(...links);
        boardView.linkToView.get(selectedLinks[0]).setHighlight(true);
        updateToolbar();
        
        if (prev === selectedLinks[0]) cycleLink();
    }

    linkEditor.openLinks([selectedLinks[0]]);
}

function centerSelection() {
    centerCards(Array.from(selectedCards));
}

function centerCards(cards) {
    scene.locked = true;
    animateElementTransform(scene.container, .2).then(() => scene.locked = false);
    const rect = boundCards(cards);
    padRect(rect, 64);
    scene.frameRect(rect, .25, 1);

    //if (cards.length === 1) window.location.replace("#" + cards[0].id);
}

function groupSelection() {
    dataManager.makeCheckpoint();
    const cards = Array.from(selectedCards).map((card) => card.id);
    const color = `rgb(${randomInt(0, 255)} ${randomInt(0, 255)} ${randomInt(0, 255)})`;
    const group = { cards, color };
    boardView.projectData.groups.push(group);
    refreshGroup(group);
    selectGroups([group]);
}

/** @type {Map<SVGElement, DominoDataGroup>} */
const svgToGroup = new Map();
/** @type {Map<SVGElement, DominoDataLink>} */
const svgToLink = new Map();

function dragGroups(event) {
    dataManager.makeCheckpoint();
    const overlapping = document.elementsFromPoint(event.clientX, event.clientY);
    const svgs = overlapping.map((overlap) => overlap.closest("svg")).filter((svg) => svg !== null);
    const groups = new Set(svgs.map((svg) => svgToGroup.get(svg)).filter((group) => group !== undefined));

    groups.forEach((group) => {
        getCardsByIds(group.cards).forEach((card) => {
            boardView.cardToView.get(card).startDrag(event);
        });
    });
    selectGroups(Array.from(groups));
}

function dragLinks(event) {
    dataManager.makeCheckpoint();
    const overlapping = document.elementsFromPoint(event.clientX, event.clientY);
    const svgs = overlapping.map((overlap) => overlap.closest("svg")).filter((svg) => svg !== null);
    const links = new Set(svgs.map((svg) => svgToLink.get(svg)).filter((link) => link !== undefined));

    links.forEach((link) => {
        getCardsByIds([link.cardA, link.cardB]).forEach((card) => {
            boardView.cardToView.get(card).startDrag(event);
        });
    });
    selectLinks(Array.from(links));
}

function onCardMoved(card) {
    boardView.projectData.groups.forEach((group) => {
        const view = boardView.groupToView.get(group) || new DominoGroupView(group);
        boardView.groupToView.set(group, view);
        if (group.cards.includes(card.id)) view.regenerateSVG();
    });

    boardView.projectData.links.forEach((link) => {
        const view = boardView.linkToView.get(link) || new DominoLinkView(link);
        boardView.linkToView.set(link, view);
        if (link.cardA === card.id || link.cardB === card.id) view.regenerateSVG();
    });
} 

function refreshGroup(group) {
    const view = boardView.groupToView.get(group) || new DominoGroupView(group);
    boardView.groupToView.set(group, view);
    view.regenerateSVG();
}

function refreshLink(link) {
    const view = boardView.linkToView.get(link) || new DominoLinkView(link);
    boardView.linkToView.set(link, view);
    view.regenerateSVG();
}

function refreshSVGs() {
    boardView.projectData.groups.forEach(refreshGroup);
    boardView.projectData.links.forEach(refreshLink);
}

const cardStyleVariables = ["card-color", "text-font", "text-size", "text-color"];
/** @param {DominoDataCardStyle} style */
function cardStyleToCss(style) {
    const declarations = [];
    cardStyleVariables.forEach((name) => {
        const value = style.properties[name];
        if (value) declarations.push(`--${name}: ${value};`);
    })

    if (style.properties["text-center"]) declarations.push("--text-align: center;");

    const rules = [
        `.style-${style.id} { ${declarations.join(" ")} }`,
    ];

    if (style.properties["icon-hide-empty"]) {
        rules.push(`.style-${style.id} .blank { display: none; }`);
    }

    // custom css prefix
    if (style.properties["custom-css"]) {
        const doc = document.implementation.createHTMLDocument("");
        const styleElement = document.createElement("style");
        styleElement.textContent = style.properties["custom-css"];
        doc.body.appendChild(styleElement);

        Array.from(styleElement.sheet.cssRules).forEach((rule) => {
            if (rule instanceof CSSStyleRule) {
                const selectors = rule.selectorText.split(",");
                const prefixed = selectors.map((selector) => {
                    if (selector.startsWith(".card-root")) {
                        return `.style-${style.id}${selector}`;
                    } else {
                        return `.style-${style.id} ${selector}`;
                    }
                }).join(",");
                rule.selectorText = prefixed;
                rules.push(rule.cssText);
            }
        });
    }

    return rules.join("\n");
}

function refreshCardStyles() {
    const element = document.getElementById("card-styles");
    const styles = boardView.projectData.cardStyles.map(cardStyleToCss);
    element.innerHTML = styles.join("\n");
    cardStyleEditor.pullData();
}

function refreshBoardStyle() {
    const style = boardView.projectData.boardStyle;
    const bgcolor = style["background-color"];

    if (bgcolor) {
        ONE("#frame").style.setProperty("background-color", bgcolor);
    }
}

/** @param {DominoDataCard} card */
function boundCard(card) {
    return new DOMRect(
        card.position.x, 
        card.position.y, 
        gridSize(card.size.x, cellWidth2, cellGap), 
        gridSize(card.size.y, cellHeight2, cellGap),
    );
}

/** @param {DominoDataCard} card */
function cardCenter(card) {
    return getRectCenter(boundCard(card));
}

/** @param {DominoDataCard[]} cards */
function boundCards(cards) {
    return boundRects(cards.map(boundCard));
}

function gridSize(cells, cellWidth, cellGap) {
    return cellWidth + (cells - 1) * (cellWidth + cellGap);
}

function getCardFromId(cardId) {
    return boardView.projectData.cards.find((card) => card.id === cardId);
}

function runCardAction(action) {
    if (action.startsWith('#')) {
        const ids = action.slice(1).split(",");
        const cards = getCardsByIds(ids);
        
        if (cards.length > 0) {
            window.location.replace('#' + ids.join(","));
            centerCards(cards);
        }
    } else if (action.startsWith('open:')) {
        window.open(action.slice(5));
    } else if (action.length > 0) {
        window.open(action);
    }
}

class DominoLinkView {
    /** @param {DominoDataLink} link */
    constructor(link) {
        this.link = link;
        this.root = svg("svg", { class: "link" });
        this.selected = false;

        const background = document.getElementById("svgs");
        background.appendChild(this.root);

        svgToLink.set(this.root, this.link);
        this.root.addEventListener("pointerdown", (event) => {
            if (!boardView.editable || event.button !== 0) return;
            killEvent(event);
            dragLinks(event);
        });
    }

    dispose() {
        this.root.remove();
    }

    setHighlight(value) {
        this.selected = value;

        if (this.selectElement) {
            this.selectElement.style.display = value ? "unset" : "none";
        }
    }

    regenerateSVG() {
        while (this.root.children.length > 0) this.root.children[0].remove();
        const [cardA, cardB] = [getCardFromId(this.link.cardA), getCardFromId(this.link.cardB)];

        const { x, y, width, height } = boundCards([cardA, cardB]);
        const rect = { x, y, width, height };

        const { x: x1, y: y1 } = cardCenter(cardA);
        const { x: x2, y: y2 } = cardCenter(cardB);
        const line = { x1, y1, x2, y2 };

        padRect(rect, 8);
        const main = svg("line", { ...line, stroke: this.link.color });
        
        //padRect(rect, 8);           
        this.selectElement = svg("line", {...line, "class": "selection-flash" });
        
        this.root.appendChild(this.selectElement);
        this.root.appendChild(main);

        {
            const rect = this.root.getBBox();
            padRect(rect, 16);
            const { x, y, width, height } = rect;
            this.root.setAttributeNS(null, "width", width.toString());
            this.root.setAttributeNS(null, "height", height.toString());
            this.root.setAttributeNS(null, "viewBox", `${x} ${y} ${width} ${height}`);
            this.root.setAttributeNS(null, "transform", translationMatrix({ x, y }).toString());
        }

        this.setHighlight(this.selected);
    }
}

class DominoGroupView {
    /**
     * @param {DominoDataGroup} group 
     */
    constructor(group) {
        this.group = group;
        this.root = svg("svg", { class: "group" });
        this.selected = false;

        const background = document.getElementById("svgs");
        background.appendChild(this.root);
        svgToGroup.set(this.root, this.group);
        this.root.addEventListener("pointerdown", (event) => {
            if (!boardView.editable || event.button !== 0) return;
            killEvent(event);
            dragGroups(event);
        });
    }

    dispose() {
        this.root.remove();
    }

    setHighlight(value) {
        this.selected = value;

        if (this.selectElement) {
            this.selectElement.style.display = value ? "unset" : "none";
        }
    }

    regenerateSVG() {
        while (this.root.children.length > 0) this.root.children[0].remove();

        const { x, y, width, height } = boundCards(getGroupCards(this.group));
        const rect = { x, y, width, height };

        padRect(rect, 8);
        const backing = svg("rect", { ...rect, rx: 16, fill: this.group.color });
        
        padRect(rect, 8);           
        this.selectElement = svg("rect", {...rect, rx: 24, fill: "gray", "class": "selection-flash" });
        
        this.root.appendChild(this.selectElement);
        this.root.appendChild(backing);

        {
            const { x, y, width, height } = this.root.getBBox();
            this.root.setAttributeNS(null, "width", width.toString());
            this.root.setAttributeNS(null, "height", height.toString());
            this.root.setAttributeNS(null, "viewBox", `${x} ${y} ${width} ${height}`);
            this.root.setAttributeNS(null, "transform", translationMatrix({ x, y }).toString());
        }

        this.setHighlight(this.selected);
    }
}

/** 
 * @param {DominoDataCard} card 
 */
function duplicateCard(card) {
    const copy = COPY(card);
    copy.id = nanoid();
    insertCard(scene, copy);
    return copy;
}

class DominoCardView {
    /**
     * @param {PanningScene} scene 
     */
    constructor(scene) {
        this.scene = scene;
        this.textElement = html("div", { class: "card-text" });
        const resize = svg("svg", { class: "resize-handle" }, svg("polygon", { points: "0,32 32,32 32,0" }));
        this.bodyElement = html("div", { class: "card-body" }, this.textElement, resize);
        this.iconElements = [0, 1, 2, 3].map((i) => html("a"));
        const iconbar = html("div", { class: "card-icon-bar" }, ...this.iconElements);
        this.rootElement = html("div", { class: "card-root" }, this.bodyElement, iconbar);

        this.iconElements.forEach((icon, index) => {
            icon.addEventListener("click", (event) => this.onIconClicked(event, index));
            icon.addEventListener('pointerdown', e => e.stopPropagation());
            icon.addEventListener('dblclick', e => e.stopPropagation());
        });
        
        ONE("#cards").appendChild(this.rootElement);

        listen(resize.children[0], "pointerdown", (event) => {
            if (!boardView.editable || event.button !== 0) return;
            killEvent(event);
            this.startResize(event);
        });

        listen(this.rootElement, "pointerdown", (event) => {
            if (!boardView.editable || event.button !== 0) return;
            killEvent(event);

            const duplicate = event.ctrlKey === true;
            const selected = selectedCards.has(this.card);
            const targets = selected ? Array.from(selectedCards) : [this.card];
            const drags = [];

            if (duplicate) {
                dataManager.makeCheckpoint();
                const copies = targets.map(duplicateCard);
                if (selected) {
                    deselectAll();
                    copies.forEach(selectCard);
                }
                drags.push(...copies.map((card) => boardView.cardToView.get(card).startDrag(event)));
                drags[0].on("click", (event) => copies.map(deleteCard));
            } else {
                dataManager.markDirty(`selected/position`);
                drags.push(...targets.map((card) => boardView.cardToView.get(card).startDrag(event)));
            }

            drags[0].on("click", (event) => selectCardToggle(this.card));
        });

        listen(this.rootElement, "dblclick", (event) => {
            killEvent(event);

            if (!boardView.editable) {
                centerCards([this.card]);
            } else {
                deselectCards();
                selectCard(this.card);
    
                invokeAction("global-editor/open");
                switchTab("sidebar/selection");
            }
        });
    }

    dispose() {
        this.rootElement.remove();
    }

    /**
     * @param {DominoDataCard} card 
     */
    setCard(card) {
        this.card = card;
        this.regenerate();
    }

    /** @param {string} value */
    setCursor(value) {
        this.rootElement.style.cursor = value;
    }

    /** @param {DOMMatrix} transform */
    setTransform(transform) {
        this.card.position = getMatrixTranslation(transform);
        setElementTransform(this.rootElement, transform);
    }

    /** @param {boolean} selected */
    setSelected(selected) {
        this.rootElement.classList.toggle("selected", selected);
    }

    regenerate() {
        if (!this.card) return;
        setElementTransform(this.rootElement, translationMatrix(this.card.position));
        this.textElement.innerHTML = parseFakedown(this.card.text);

        const bounds = boundCard(this.card);
        this.rootElement.style.width = `${bounds.width}px`;
        this.rootElement.style.height = `${bounds.height}px`;
        this.rootElement.setAttribute("class", "card-root " + "style-" + this.card.style ?? "");
        this.setSelected(selectedCards.has(this.card));

        this.card.icons.forEach((data, i) => {
            const element = this.iconElements[i];
            element.innerHTML = data.icon;
            
            if (data.action === "") {
                element.removeAttribute("href");
            } else {
                element.href = data.action;
            }

            element.classList.toggle('blank', data.icon === '');
            element.classList.toggle('cosmetic', data.action === '');
        });

        if (this.card.image) {
            this.bodyElement.style.setProperty('background-image', `url(${this.card.image})`);
        }

        this.bodyElement.classList.toggle('has-image', !!this.card.image);
    }

    /** 
     * @param {MouseEvent} event
     * @param {number} index
     */
    onIconClicked(event, index) {
        killEvent(event);
        runCardAction(this.card.icons[index].action);
    }

    /** @param {PointerEvent} event */
    startResize(event) {
        function fit(value, cellSize, cellGap) {
            let cells;
            for (cells = 1; gridSize(cells, cellSize, cellGap) < value - cellGap; ++cells);
            return cells;
        }

        const { x: x1, y: y1 } = getMatrixTranslation(this.scene.mouseEventToSceneTransform(event));
        const [w1, h1] = [this.rootElement.clientWidth, this.rootElement.clientHeight];

        // create target shadow
        const target = html("div", { class: "target" });
        this.scene.container.appendChild(target);
        setElementTransform(target, translationMatrix(this.card.position));

        const gesture = trackGesture(event);
        gesture.on("pointermove", (event) => {
            const { x: x2, y: y2 } = getMatrixTranslation(this.scene.mouseEventToSceneTransform(event));
            const [dx, dy] = [x2 - x1, y2 - y1];
            const [w2, h2] = [w1 + dx, h1 + dy];

            this.card.size.x = Math.max(2, fit(w2, cellWidth2, cellGap));
            this.card.size.y = Math.max(2, fit(h2, cellHeight2, cellGap));

            this.rootElement.style.width = `${w2}px`;
            this.rootElement.style.height = `${h2}px`;

            const bounds = boundCard(this.card);
            target.style.width = `${bounds.width}px`;
            target.style.height = `${bounds.height}px`;
            onCardMoved(this.card);
        });
        gesture.on("pointerup", (event) => {
            const bounds = boundCard(this.card);
            this.rootElement.style.width = `${bounds.width}px`;
            this.rootElement.style.height = `${bounds.height}px`;

            // snap card to grid
            animateElementSize(this.rootElement, .1).then(() => target.remove());
            target.remove();
            
            onCardMoved(this.card);
        });
        gesture.emit("pointermove", event);
    }

    /** @param {PointerEvent} event */
    startDrag(event) {
        // determine and save the relationship between mouse and element
        // G = M1^ . E (element relative to mouse)
        const mouse = this.scene.mouseEventToSceneTransform(event);
        const grab = mouse.invertSelf().multiplySelf(translationMatrix(this.card.position));

        const initialPosition = this.card.position;

        // create target shadow
        const target = html("div", { class: "target" });
        this.scene.container.appendChild(target);
        setElementTransform(target, translationMatrix(this.card.position));
        const bounds = boundCard(this.card);
        target.style.width = `${bounds.width}px`;
        target.style.height = `${bounds.height}px`;

        const drag = trackGesture(event);
        drag.on("pointermove", (event) => {
            // preserve the relationship between mouse and element
            // D2 = M2 . G (drawing relative to scene)
            const mouse = this.scene.mouseEventToSceneTransform(event);
            const transform = mouse.multiply(grab);

            // card drags free from the grid
            this.setTransform(transform);
            // target shadow snaps to grid as card would
            gridSnap(transform);
            setElementTransform(target, transform);

            // TODO: this has gotta have a bigger system for updating
            // on drag and during snap animation etc
            onCardMoved(this.card);
        });
        drag.on("pointerup", (event) => {
            const mouse = this.scene.mouseEventToSceneTransform(event);
            const transform = mouse.multiply(grab);
            
            // snap card to grid
            animateElementTransform(this.rootElement, .1).then(() => target.remove());
            gridSnap(transform);
            this.setTransform(transform);

            this.setCursor("grab");

            // TODO:
            onCardMoved(this.card);

            if (this.card.position.x === initialPosition.x && this.card.position.y === initialPosition.y) {
                dataManager.cancelDirty(`selected/position`);
            } else {
                dataManager.confirmDirty(`selected/position`);
            }
        });

        this.setCursor("grabbing");

        return drag;
    }
}

/** @param {DOMMatrix} transform */
function snap(transform, gx = 1, gy = gx) {
    transform.e = Math.round(transform.e / gx) * gx;
    transform.f = Math.round(transform.f / gy) * gy;
}

function gridSnap(transform) {
    return snap(transform, cellWidth/2, cellHeight/2);
}

/**
 * @param {HTMLElement} element 
 * @param {DOMMatrixReadOnly} transform 
 */
function setElementTransform(element, transform) {
    element.style.setProperty("transform", transform.toString());
}

/**
 * @param {HTMLElement} element 
 * @param {number} duration 
 */
async function animateElementTransform(element, duration) {
    element.style.transition = `transform ${duration}s ease-in-out`;
    await sleep(duration * 1000);
    element.style.transition = "none";
}

/**
 * @param {HTMLElement} element 
 * @param {number} duration 
 */
 async function animateElementSize(element, duration) {
    element.style.transition = `width ${duration}s ease-in-out, height ${duration}s ease-in-out`;
    await sleep(duration * 1000);
    element.style.transition = "none";
}

/** 
 * @param {PointerEvent} event 
 */
function trackGesture(event) {
    const emitter = new EventEmitter();
    const pointer = event.pointerId;

    const clickMovementLimit = 5;
    let totalMovement = 0;

    const removes = [
        listen(document, "pointerup", (event) => {
            if (event.pointerId !== pointer) return;

            removes.forEach((remove) => remove());
            emitter.emit("pointerup", event);
            if (totalMovement <= clickMovementLimit) emitter.emit("click", event);
        }),
        listen(document, "pointermove", (event) => {
            if (event.pointerId !== pointer) return;

            totalMovement += Math.abs(event.movementX);
            totalMovement += Math.abs(event.movementY);
            emitter.emit("pointermove", event);
        }),
    ];

    return emitter;
}

class PointerDrag {
    /** 
     * @param {PointerEvent} event
     */
    constructor(event, { clickMovementLimit = 5 } = {}) {
        this.events = new EventEmitter();
        this.pointerId = event.pointerId;
        this.clickMovementLimit = 5;
        this.totalMovement = 0;

        this.downEvent = event;
        this.lastEvent = event; 

        this.removes = [
            listen(document, "pointerup", (event) => {
                if (event.pointerId !== this.pointerId) return;
    
                this.lastEvent = event;
                this.removes.forEach((remove) => remove());
                this.events.emit("pointerup", event);
                if (this.totalMovement <= clickMovementLimit) {
                    this.events.emit("click", event);
                }
            }),
            listen(document, "pointermove", (event) => {
                if (event.pointerId !== this.pointerId) return;
    
                this.totalMovement += Math.abs(event.movementX);
                this.totalMovement += Math.abs(event.movementY);
                this.lastEvent = event;
                this.events.emit("pointermove", event);
            }),
        ];
    }

    cancel() {
        this.removes.forEach((remove) => remove());
    }
}

const imageSize = [512, 512];

async function fileToCompressedImageURL(file) {
    const url = await dataURLFromFile(file);
    const dataURL = await compressImageURL(url, 0.2, imageSize);
    return dataURL;
}

async function dataTransferToImage(dt) {
    const files = filesFromDataTransfer(dt);
    const element = elementFromDataTransfer(dt);
    if (files.length > 0) {
        return await fileToCompressedImageURL(files[0]);
    } else if (element && element.nodeName === 'IMG') {
        return await compressImageURL(element.src, .2, imageSize);
    }
}

function filesFromDataTransfer(dataTransfer) {
    const clipboardFiles = 
        Array.from(dataTransfer.items || [])
        .filter(item => item.kind === 'file')
        .map(item => item.getAsFile());
    return clipboardFiles.concat(...(dataTransfer.files || []));
}

function elementFromDataTransfer(dataTransfer) {
    const html = dataTransfer.getData('text/html');
    return html && stringToElement(html);
}

async function compressImageURL(url, quality, size) {
    const image = document.createElement("img");
    image.crossOrigin = "true";
    const canvas = document.createElement("canvas");

    const [tw, th] = size;
    canvas.width = tw;
    canvas.height = th;

    return new Promise((resolve, reject) => {
        image.onload = () => {
            const scale = Math.min(tw / image.width, th / image.height);
            canvas.width = image.width * scale;
            canvas.height = image.height * scale;
            const context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, canvas.width, canvas.height);
            const url = canvas.toDataURL('image/jpeg', quality);

            resolve(url);
        };
        image.onerror = () => resolve(undefined);
        image.src = url;
    });
}

function stringToDocument(string) {
    const template = document.createElement('template');
    template.innerHTML = string;
    return template.content;
}

function stringToElement(string) {
    return stringToDocument(string).children[0];
}

class DominoProjectManager {
    get data() {
        return this.history[this.index];
    }

    get canUndo() {
        return this.index > 0 || this.dirty;
    }

    get canRedo() {
        return this.index < this.history.length - 1 && !this.dirty;
    }

    constructor() {
        /** @type {DominoDataProject[]} */
        this.history = [];
        this.index = -1;
        this.historyLimit = 20;
        this.dirty = undefined;
    }

    /**
     * @param {DominoDataProject} data 
     */
    reset(data) {
        deselectAll();

        this.history.length = 0;
        this.history.push(data);
        this.index = 0;
        boardView.loadProject(this.data);
    }

    markDirty(path="generic") {
        if (path === this.dirty) return;
        this.makeCheckpoint();
        this.dirty = path;
    }

    cancelDirty(path) {
        if (path !== this.dirty) return;
        this.history.splice(this.index, 1);
        this.index -= 1;
        this.dirty = undefined;
        updateToolbar();
    }

    confirmDirty(path) {
        if (path !== this.dirty) return;
        this.dirty = undefined;
        updateToolbar();
    }

    makeCheckpoint() {
        this.dirty = undefined;
        this.history.length = this.index + 1;
        
        this.history[this.index] = COPY(boardView.projectData);
        this.history.push(boardView.projectData);
        
        if (this.index < this.historyLimit) {
            this.index += 1;
        } else {
            // delete earliest history
            this.history.splice(0, 1);
        }
        
        updateToolbar();
    }

    undo() {
        if (!this.canUndo) return;
        this.index -= 1;
        deselectAll();
        boardView.loadProject(this.data);
        this.dirty = undefined;
    }

    redo() {
        if (!this.canRedo) return;
        this.index += 1;
        deselectAll();
        boardView.loadProject(this.data);
        this.dirty = undefined;
    }
}

async function downloadGoogleFont(url) {
    const face = await fetch(url).then((r) => r.text());
    const [, srcURL] = face.match(/url\((http.*woff2)\)/);
    const [, family] = face.match(/font-family: ['"](.*)["'];/);
    const dataURL = await fetch(srcURL).then((r) => r.blob()).then(dataURLFromFile);
    return { family, css: face.replace(srcURL, dataURL) };
}

async function replaceFont(url) {
    const { family, css } = await downloadGoogleFont(url);
    ONE("#active-font").textContent = css;
    ONE("#font").textContent = css;
    ONE("#font").setAttribute("data-font-family", family);
    document.body.style.fontFamily = family;
}

    </script>
    <script id="editor/card-editor.js">class CardEditor {
    constructor() {
        /** @type {DominoDataCard[]} */
        this.cards = [];
        
        //this.container = elementByPath("card-editor", "div");
        this.promptText = elementByPath("selection/prompt", "span");

        this.textInput = elementByPath("card-editor/text/value", "textarea");
        this.altTextInput = elementByPath("card-editor/image/alt", "textarea");
        this.styleList = elementByPath("card-editor/styles", "select");

        this.iconIconInputs = /** @type {HTMLInputElement[]} */ ([1, 2, 3, 4].map((i) => elementByPath(`card-editor/icons/${i}/icon`, "input")));
        this.iconActionInputs = /** @type {HTMLInputElement[]} */ ([1, 2, 3, 4].map((i) => elementByPath(`card-editor/icons/${i}/action`, "input")));

        [0, 1, 2, 3].forEach((i) => {
            this.iconIconInputs[i].addEventListener("input", () => {
                dataManager.markDirty(this.cards[0].id + "/icons");
                this.pushData();
            });
            this.iconActionInputs[i].addEventListener("input", () => {
                dataManager.markDirty(this.cards[0].id + "/icons");
                this.pushData();
            });
        });

        this.textInput.addEventListener("input", () => {
            dataManager.markDirty(this.cards[0].id + "/text");
            this.pushData();
        });

        this.altTextInput.addEventListener("input", () => {
            dataManager.markDirty(this.cards[0].id + "/alttext");
            this.pushData();
        });

        setActionHandler("card-editor/image/upload", async () => {
            const [file] = await pickFiles("image/*");
            if (!file) return;
            dataManager.makeCheckpoint();
            this.cards[0].image = await fileToCompressedImageURL(file);
            this.pushData();
        });

        setActionHandler("card-editor/image/remove", () => {
            if (!this.cards[0].image) return;
            dataManager.makeCheckpoint();
            this.cards[0].image = undefined;
            this.pushData();
        });

        setActionHandler("card-editor/text/bold", () => this.wrapSelectedText("**", "**"));
        setActionHandler("card-editor/text/italic", () => this.wrapSelectedText("*", "*"));
        setActionHandler("card-editor/text/strike", () => this.wrapSelectedText("~~", "~~"));
        setActionHandler("card-editor/text/header", () => this.wrapSelectedText("##", "##"));

        setActionHandler("card-editor/styles/edit", () => {
            cardStyleEditor.open();
            cardStyleEditor.setSelectedStyle(this.styleList.value);
            switchTab("sidebar/styles");
        });

        this.styleList.addEventListener("change", () => {
            dataManager.makeCheckpoint();
            this.pushData();
        });
    }

    /** @param {DominoDataCard[]} cards */
    openMany(cards) {
        this.promptText.textContent = `${cards.length} cards selected`;

        elementByPath("card-editor/text", "div").hidden = cards.length > 1;
        elementByPath("card-editor/icons", "div").hidden = cards.length > 1;
        elementByPath("card-editor/image", "div").hidden = cards.length > 1;
        elementByPath("card-editor/style", "div").hidden = false;
        elementByPath("selection/link", "button").hidden = cards.length !== 1;
        elementByPath("selection/group", "button").hidden = cards.length === 1;
        this.cards = cards;
        this.pullData();

        refreshDropdown(
            this.styleList,
            [{id: "default", name: "default"}, ...boardView.projectData.cardStyles],
            (style) => html("option", { value: style.id }, style.name),
        );
    }

    close() {
        this.cards = []; 

        this.promptText.textContent = `no cards selected`;
        elementByPath("card-editor/text", "div").hidden = true;
        elementByPath("card-editor/icons", "div").hidden = true;
        elementByPath("card-editor/image", "div").hidden = true;
        elementByPath("card-editor/style", "div").hidden = true;
    }

    pullData() {
        if (this.cards.length === 1) {
            const [card] = this.cards;

            this.textInput.value = card.text;
            this.altTextInput.value = card.alttext || "";

            card.icons.slice(0, 4).forEach((icon, i) => {
                this.iconIconInputs[i].value = icon.icon;
                this.iconActionInputs[i].value = icon.action;
            });

            [0, 1, 2, 3].forEach((i) => {
                const icon = card.icons[i] || { icon: "", action: "" };

                this.iconIconInputs[i].value = icon.icon;
                this.iconActionInputs[i].value = icon.action;
            });

            this.styleList.value = card.style ?? "";
        } else {
            const styles = new Set(this.cards.map((card) => card.style));
            const [style] = styles.size === 1 ? styles : [undefined];
            this.styleList.value = style;
        }
    }

    pushData() {
        if (this.cards.length === 1) {
            const [card] = this.cards;
            card.text = this.textInput.value;
            card.icons = [0, 1, 2, 3].map((i) => {
                return { 
                    icon: this.iconIconInputs[i].value, 
                    action: this.iconActionInputs[i].value,
                };
            });
            card.alttext = this.altTextInput.value;
            card.style = this.styleList.value;
        } else {
            const style = this.styleList.value;
            if (style) this.cards.forEach((card) => card.style = style);
        }
    
        this.cards.forEach((card) => boardView.cardToView.get(card).regenerate());
    }

    /** @param {ClipboardEvent} event */
    async paste(event) {
        if (this.cards.length !== 1) return;
        const [card] = this.cards;

        const image = await dataTransferToImage(event.clipboardData);

        if (image) {
            dataManager.makeCheckpoint();
            card.image = image;
            this.pushData();
            killEvent(event);
        }
    }

    /**
     * @param {string} prefix
     * @param {string} suffix
     */
    wrapSelectedText(prefix, suffix) {
        dataManager.markDirty(this.cards[0].id + "/text");
        const start = this.textInput.selectionStart;
        const end = this.textInput.selectionEnd;
        const text = this.textInput.value.substring(start, end);
        const prev = this.textInput.value;
        const next = prev.slice(0, start) + prefix + text + suffix + prev.slice(end);

        this.textInput.value = next;
        this.pushData();

        this.textInput.select();
        this.textInput.setSelectionRange(start + prefix.length, end + prefix.length);
    }
}

    </script>
    <script id="editor/cardstyle-editor.js">function deleteCardStyle(style) {
    arrayDiscard(boardView.projectData.cardStyles, style);
    boardView.projectData.cards.forEach((card) => {
        if (card.style === style.id) delete card.style;
    });
    refreshCardStyles();
}

// please don't tell anyone how i live..
class CardStyleEditorRow {
    /**
     * @param {string} name 
     * @param {keyof DominoDataCardStyle["properties"]} key 
     * @param {HTMLElement[]} inputs 
     */
    constructor(editor, name, key, ...inputs) {
        this.editor = editor;
        this.toggle = html("input", { type: "checkbox", class: "check" });
        this.label = html("span", {}, name);

        this.name = name;
        this.key = key;

        this.elements = [this.toggle, this.label, ...inputs];

        this.toggle.addEventListener("change", () => {
            inputs.forEach((input) => input.disabled = !this.toggle.checked);
            this.push();
        });

        inputs.forEach((input) => input.disabled = true);
        inputs.forEach((input) => input.addEventListener("input", () => this.push()));
    }

    push() {
        const style = this.editor.getSelectedStyle();
        if (!style) return;
        this.pushData(style);
        refreshCardStyles();
    }

    /** @param {DominoDataCardStyle} style */
    pullData(style) {
        
    }

    pushData(style) {
        
    }
}

class CardStyleSize extends CardStyleEditorRow {
    constructor(editor, name, key, min, max, unit="px") {
        const input = html("input", { type: "range", min, max });
        super(editor, name, key, input);
        this.input = input;
        this.unit = unit;
    }

    /** @param {DominoDataCardStyle} style */
    pullData(style) {
        const value = style.properties[this.key];

        if (value !== undefined) {
            this.toggle.checked = true;
            this.input.disabled = false;
            this.input.value = value.slice(0, -this.unit.length);
        } else {
            this.toggle.checked = false;
            this.input.disabled = true;
        }
    }

    /** @param {DominoDataCardStyle} style */
    pushData(style) {
        style.properties[this.key] = this.toggle.checked 
                                   ? this.input.value + this.unit 
                                   : undefined;
    }
}

class CardStyleColor extends CardStyleEditorRow {
    constructor(editor, name, key, alpha=false) {
        const input = html("input", { type: "color" });
        const slider = alpha ? html("input", { type: "range", min: "0", max: "255" }) : undefined;
        if (slider) {
            super(editor, name, key, input, slider);
        } else {
            super(editor, name, key, input);
        }
        this.input = input;
        this.slider = slider;
    }

    /** @param {DominoDataCardStyle} style */
    pullData(style) {
        const value = style.properties[this.key];

        if (value !== undefined) {
            this.toggle.checked = true;
            this.input.disabled = false;
            this.input.value = value.slice(0, 7);
            
            if (this.slider) {
                this.slider.value = parseInt(value.slice(-2), 16).toString();
                this.slider.disabled = false;
            }
        } else {
            this.toggle.checked = false;
            this.input.disabled = true;
            if (this.slider) this.slider.disabled = true;
        }
    }

    /** @param {DominoDataCardStyle} style */
    pushData(style) {
        const alpha = this.slider ? this.slider.valueAsNumber.toString(16) : "ff";
        style.properties[this.key] = this.toggle.checked 
                                   ? this.input.value + alpha
                                   : undefined;
    }
}

class CardStyleToggle extends CardStyleEditorRow {
    /** @param {DominoDataCardStyle} style */
    pullData(style) {
        this.toggle.checked = style.properties[this.key] !== undefined;
    }

    /** @param {DominoDataCardStyle} style */
    pushData(style) {
        style.properties[this.key] = this.toggle.checked ? "true" : undefined;
    }
}

class CardStyleSelect extends CardStyleEditorRow {
    constructor(editor, name, key) {
        const input = html("select", {});
        super(editor, name, key, input);
        this.select = input;
    }

    /** @param {DominoDataCardStyle} style */
    pullData(style) {
        const value = style.properties[this.key];

        if (value !== undefined) {
            this.toggle.checked = true;
            this.select.disabled = false;
            this.select.value = value;
        } else {
            this.toggle.checked = false;
            this.select.disabled = true;
        }
    }

    /** @param {DominoDataCardStyle} style */
    pushData(style) {
        style.properties[this.key] = this.toggle.checked 
                                   ? this.select.value 
                                   : undefined;
    }
}

class CardStyleEditor {
    constructor() {
        this.root = elementByPath("global-editor", "div");

        const container = document.getElementById("card-style-fields");

        this.titleInput = elementByPath("global-editor/title", "input");
        this.focusInput = elementByPath("global-editor/focus", "input");
        this.backgroundColorInput = elementByPath("global-editor/style/background-color", "input");

        this.nameInput = elementByPath("global-editor/card-styles/selected/name", "input");
        this.textFontRow = new CardStyleSelect(this, "font", "text-font");

        this.rows = [
            new CardStyleSize(this, "size", "text-size", 8, 64),
            new CardStyleColor(this, "color", "text-color"),
            new CardStyleToggle(this, "center", "text-center"),
            new CardStyleColor(this, "color", "card-color", true),
            this.textFontRow,
        ];

        container.replaceChildren(
            html("h2", {}, "text"),
            html("div", { class: "settings-grid" },
                ...this.textFontRow.elements,
                ...this.rows[0].elements,
                ...this.rows[1].elements,
                ...this.rows[2].elements,
            ),
            html("h2", {}, "card"),
            html("div", { class: "settings-grid" },
                ...this.rows[3].elements,
            ),
        );

        this.backgroundColorInput.addEventListener("input", () => {
            dataManager.markDirty("global/background-color");
            boardView.projectData.boardStyle["background-color"] = this.backgroundColorInput.value;
            refreshBoardStyle();
        });

        this.focusInput.addEventListener("input", () => {
            dataManager.markDirty("global/focus");
            boardView.projectData.details.focus = this.focusInput.value;
        });

        this.nameInput.addEventListener("input", () => {
            const style = this.getSelectedStyle();
            if (style) {
                dataManager.markDirty(this.selectedStyleId + "/name");
                style.name = this.nameInput.value;
            }
        });

        this.styleSelect = elementByPath("global-editor/card-styles/selected", "select");
        this.styleSelect.addEventListener("change", () => {
            this.setSelectedStyle(this.styleSelect.value);
        });

        this.customCssInput = elementByPath("global-editor/card-styles/selected/custom-css", "textarea");
        this.customCssInput.addEventListener("input", () => {
            const style = this.getSelectedStyle();
            if (style) {
                dataManager.markDirty(this.selectedStyleId + "/custom-css");
                style.properties["custom-css"] = this.customCssInput.value;
                refreshCardStyles();
            }
        });

        this.titleInput.addEventListener("input", () => {
            dataManager.markDirty("global/title");
            boardView.projectData.details.title = this.titleInput.value;
        });

        setActionHandler("global-editor/open", () => this.open());
        setActionHandler("global-editor/close", () => this.close());
        setActionHandler("global-editor/toggle", () => this.toggle());

        setActionHandler("global-editor/card-style/new", () => {
            dataManager.makeCheckpoint();
            const style = {
                id: nanoid(),
                name: "new style",
                properties: {},
            };

            boardView.projectData.cardStyles.push(style);
            this.setSelectedStyle(style.id);
        });

        setActionHandler("global-editor/card-style/selected/duplicate", () => {
            dataManager.makeCheckpoint();
            const style = this.getSelectedStyle();
            const copy = JSON.parse(JSON.stringify(style));
            copy.id = nanoid();
            copy.name += " (copy)";
            boardView.projectData.cardStyles.push(copy);
            this.setSelectedStyle(copy.id);
        });

        setActionHandler("global-editor/card-style/selected/delete", () => {
            if (boardView.projectData.cardStyles.length <= 1) return;
            dataManager.makeCheckpoint();
            const style = this.getSelectedStyle();
            deleteCardStyle(style);
            this.setSelectedStyle(boardView.projectData.cardStyles[0].id);
        });
    }

    getSelectedStyle() {
        const styles = boardView.projectData.cardStyles;
        return styles.find((style) => style.id === this.selectedStyleId);
    }

    pullData() {
        this.titleInput.value = boardView.projectData.details.title;
        this.focusInput.value = boardView.projectData.details.focus;
        this.backgroundColorInput.value = boardView.projectData.boardStyle["background-color"] || "#b7b8b0";

        refreshDropdown(
            this.styleSelect,
            boardView.projectData.cardStyles,
            (style) => html("option", { value: style.id }, style.name),
        );

        if (!this.selectedStyleId) this.selectedStyleId = boardView.projectData.cardStyles[0].id;
        this.styleSelect.value = this.selectedStyleId;

        refreshDropdown(
            this.textFontRow.select,
            ["default", "monospace", "serif", "sans-serif", "cursive"],
            (font) => html("option", { value: font }, font),
        );

        const style = this.getSelectedStyle();
        if (!style) return;

        this.nameInput.value = style.name;
        this.rows.forEach((row) => row.pullData(style));
        this.customCssInput.value = style.properties["custom-css"] || "";

        const deleteButton = elementByPath("global-editor/card-style/selected/delete", "button");
        deleteButton.disabled = boardView.projectData.cardStyles.length <= 1;
    }

    setSelectedStyle(styleId) {
        this.selectedStyleId = styleId;
        this.pullData();
    }

    open() {
        this.root.hidden = false;
        this.pullData();
    }

    close() {
        this.root.hidden = true;
    }

    toggle() {
        if (this.root.hidden) this.open();
        else this.close();
    }
}

    </script>
    <script id="editor/editor.js">function saveAs(blob, name) {
    const element = document.createElement("a");
    const url = window.URL.createObjectURL(blob);
    element.href = url;
    element.download = name;
    element.click();
    window.URL.revokeObjectURL(url);
};

/** @param {DominoDataProject} projectData */
function createStandalonePlayer(projectData) {
    const clone = /** @type {HTMLElement} */ (document.documentElement.cloneNode(true));
    ALL("[data-empty]", clone).forEach((element) => element.replaceChildren());
    ALL("[data-editor-only]", clone).forEach((element) => element.remove());
    ONE("body", clone).setAttribute("data-player", "true");
    ONE("title", clone).innerHTML = projectData.details.name;
    ONE("#project-data", clone).innerHTML = JSON.stringify(projectData);
    ONE('[data-path="global-editor"]', clone).hidden = true;
    ONE('#sidebar-toggle', clone).hidden = true;
    return clone;
}

const projectToHTML = () => {
    const clone = createStandalonePlayer(boardView.projectData);
    return clone.outerHTML;
}

setActionHandler("project/export/html", async () => {
    const name = boardView.projectData.details.name + ".html";
    const blob = textToBlob(projectToHTML(), "text/html");
    saveAs(blob, name);
});

setActionHandler("global/import", async () => {
    const [file] = await pickFiles("text/html");
    const text = await textFromFile(file);
    const html = await htmlFromText(text);

    const json = ONE("#project-data", html).innerHTML;
    const projectData = JSON.parse(json);
    projectData.details.id = nanoid();
    dataManager.reset(projectData);
});

setActionHandler("global/new", async () => {
    /** @type {DominoDataProject} */
    const blank = {
        details: {
            id: nanoid(),
            title: "new project",
            name: "project",
            focus: "",
        },
        cards: [],
        groups: [],
        links: [],
        cardStyles: COPY(boardView.projectData.cardStyles),
        boardStyle: COPY(boardView.projectData.boardStyle), 
    }

    dataManager.reset(blank);
});

async function refreshSaves() {
    const saves = await listProjects();
    saves.sort((a, b) => (new Date(b.date)).getTime() - (new Date(a.date)).getTime());

    const options = saves.map(({ title, date, id }) => {
        const date_ = new Date(date).toLocaleDateString();
        const label = `${title} (${date_})`;
        return html("option", { value: id }, label);
    });
    elementByPath("global/saves", "select").replaceChildren(...options);
}

setActionHandler("project/save", async () => {
    const timer = sleep(250);
    const saveButton = ONE("#save");
    saveButton.disabled = true;
    saveButton.innerText = "";
    await saveProject(boardView.projectData, boardView.projectData.details.id);
    refreshSaves();
    await timer;
    saveButton.disabled = false;
    saveButton.innerText = ""
});

setActionHandler("global/saves/load", async () => {
    const id = elementByPath("global/saves", "select").value;
    return loadProjectAction(id);
});

async function loadProjectAction(id) {
    const project = await loadProject(id);
    dataManager.reset(project);
    invokeAction("global/center-focus");
    
    const url = new URL(window.location.href);
    url.searchParams.set("load", id);
    window.history.pushState({}, "", url.href);
}

setActionHandler("global/saves/duplicate", async () => {
    const id = elementByPath("global/saves", "select").value;
    const project = COPY(await loadProject(id));
    project.details.id = nanoid();
    project.details.title += " (copy)";
    await saveProject(project, project.details.id);
    refreshSaves();
});

setActionHandler("global/saves/delete", async () => {
    const id = elementByPath("global/saves", "select").value;
    await deleteProject(id);
    refreshSaves();
});

setActionHandler("show:sidebar/board", refreshSaves);

setActionHandler("project/publish/neocities", async () => {
    const ready = new Promise((resolve, reject) => {
        const remove = listen(window, "message", (event) => {
            if (event.origin !== "https://kool.tools") return;
            remove();
            resolve();
        });
    });

    const success = new Promise((resolve, reject) => {
        const remove = listen(window, "message", (event) => {
            if (event.origin !== "https://kool.tools") return;

            if (event.data.error) {
                remove();
                reject(event.data.error);
            } else if (event.data.url) {
                remove();
                resolve(event.data.url);
            }
        });
    });

    const name = boardView.projectData.details.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    const popup = window.open(
        "https://kool.tools/neocities-publisher/index.html", 
        "neocities publisher",
        "left=10,top=10,width=320,height=320");
    const html = projectToHTML();
    await ready;
    popup.postMessage({ name, html }, "https://kool.tools");
    const url = await success;
    popup.close();

    const viewButton = ONE("#neocities-view");
    viewButton.disabled = false;
    viewButton.onclick = () => window.open(url);
});

class LinkEditor {
    constructor() {
        this.colorInput = elementByPath("link/color", "input");
        /** @type {DominoDataLink[]} */
        this.links = [];

        this.colorInput.addEventListener("input", () => {
            dataManager.markDirty("links");
            this.links.forEach((link) => {
                link.color = this.colorInput.value;
                boardView.linkToView.get(link).regenerateSVG();
            });
        });
    }

    /** @param {DominoDataLink[]} links */
    openLinks(links) {
        this.links = links;
        
        if (links.length === 1) this.colorInput.value = links[0].color;
    }

    close() {
        this.links = [];
    }
}

class GroupEditor {
    constructor() {
        this.colorInput = elementByPath("group/color", "input");
        /** @type {DominoDataGroup[]} */
        this.groups = [];

        this.colorInput.addEventListener("input", () => {
            dataManager.markDirty("group");
            this.groups.forEach((group) => {
                group.color = this.colorInput.value;
                boardView.groupToView.get(group).regenerateSVG();
            });
        });
    }

    /** @param {DominoDataGroup[]} groups */
    openGroups(groups) {
        this.groups = groups;
        
        if (groups.length === 1) this.colorInput.value = groups[0].color;
    }

    close() {
        this.groups = [];
    }
}


    </script>
    <script id="player.js">/** @param {DominoDataProject} projectData */
function repairProjectData(projectData) {
    const cardIds = new Set(projectData.cards.map((card) => card.id));
    projectData.links = projectData.links.filter((link) => cardIds.has(link.cardA) && cardIds.has(link.cardB));
    projectData.groups = projectData.groups.filter((group) => new Set([...group.cards, ...cardIds]).size === cardIds.size);
}

class DominoBoardView {
    constructor() {
        /** @type {Map<DominoDataCard, DominoCardView>} */
        this.cardToView = new Map();
        /** @type {Map<DominoDataGroup, DominoGroupView>} */
        this.groupToView = new Map();
        /** @type {Map<DominoDataLink, DominoLinkView>} */
        this.linkToView = new Map();

        this.editable = true;
    }

    /** @param {DominoDataProject} projectData */
    loadProject(projectData) {
        repairProjectData(projectData);

        this.clear();
        this.projectData = projectData;

        this.projectData.cards.forEach((card) => {
            const view = new DominoCardView(scene);
            view.setCard(card);
            this.cardToView.set(card, view);
        });

        refreshSVGs();
        refreshCardStyles();
        refreshBoardStyle();
    }

    clear() {
        this.projectData = undefined;
        this.cardToView.forEach((view) => view.dispose());
        this.groupToView.forEach((view) => view.dispose());
        this.linkToView.forEach((view) => view.dispose());
        this.cardToView.clear();
        this.groupToView.clear();
        this.linkToView.clear();
    }
}

class TransformGesture {
    tryAddPointerDrag(event) {
        const drag = new PointerDrag(event);
        drag.events.on("pointermove", () => {

        });
    }
}

class PanningScene {
    get hidden() { return this.container.hidden; }
    set hidden(value) { this.container.hidden = value; }

    /**
     * @param {HTMLElement} container 
     */
    constructor(container) {
        this.viewport = container.parentElement;
        this.container = container;
        this.transform = new DOMMatrix();
        this.locked = false;

        this.minScale = 1 / 8;
        this.maxScale = 2;

        this.pointerA = undefined;
        this.pointerB = undefined;
        let ratio = 1;

        this.viewport.addEventListener("pointerdown", (event) => {
            if (this.hidden || this.locked) return;
            killEvent(event);

            if (!this.pointerA) {
                // determine and save the relationship between mouse and scene
                // G = M1^ . S (scene relative to mouse)
                const mouse = this.mouseEventToViewportTransform(event);
                const grab = mouse.invertSelf().multiplySelf(this.transform);
                document.body.style.setProperty("cursor", "grabbing");
                this.viewport.style.setProperty("cursor", "grabbing");
                this.container.classList.toggle("skip-transition", true);

                ratio = 1;
                const drag = new PointerDrag(event);
                drag.events.on("pointermove", (event) => {
                    // preserve the relationship between mouse and scene
                    // D2 = M2 . G (drawing relative to scene)
                    const mouse = this.mouseEventToViewportTransform(event);
                    mouse.scaleSelf(ratio, ratio);
                    this.transform = mouse.multiply(grab);
                    this.refresh();
                });
                drag.events.on("pointerup", (event) => {
                    document.body.style.removeProperty("cursor");
                    this.viewport.style.removeProperty("cursor");
                    this.container.classList.toggle("skip-transition", false);

                    if (this.pointerB) this.pointerB.cancel();

                    this.pointerA = undefined;
                    this.pointerB = undefined;
                });
                drag.events.on("click", (event) => {
                    deselectAll();
                });

                this.pointerA = drag;
            } else if (!this.pointerB) {
                const mouseB = this.mouseEventToViewportTransform(event);
                const mouseA = this.mouseEventToViewportTransform(this.pointerA.lastEvent);
                const dx = mouseB.e - mouseA.e;
                const dy = mouseB.f - mouseA.f;
                const initialD = Math.sqrt(dx*dx + dy*dy); 

                this.pointerB = new PointerDrag(event);
                this.pointerB.events.on("pointermove", (event) => {
                    const mouseB = this.mouseEventToViewportTransform(event);
                    const mouseA = this.mouseEventToViewportTransform(this.pointerA.lastEvent);
                    const dx = mouseB.e - mouseA.e;
                    const dy = mouseB.f - mouseA.f;
                    const currentD = Math.sqrt(dx*dx + dy*dy);
                    ratio = currentD / initialD;
                });
                this.pointerB.events.on("pointerup", () => {
                    this.pointerB = undefined;
                });
            }
        });
        
        this.viewport.addEventListener('wheel', (event) => {
            if (this.hidden || this.locked) return;

            event.preventDefault();

            const mouse = this.mouseEventToViewportTransform(event);
            const origin = (this.transform.inverse().multiply(mouse)).transformPoint();

            const deltaY = event.deltaMode === 0 ? event.deltaY : event.deltaY * 33;

            const prevScale = getMatrixScale(this.transform).x;
            const [minDelta, maxDelta] = [this.minScale/prevScale, this.maxScale/prevScale];
            const magnitude = Math.min(Math.abs(deltaY), 25);
            const exponent = Math.sign(deltaY) * magnitude * -.01;
            const deltaScale = clamp(Math.pow(2, exponent), minDelta, maxDelta);

            // prev * delta <= max -> delta <= max/prev
            this.transform.scaleSelf(
                deltaScale, deltaScale, deltaScale,
                origin.x, origin.y, origin.z,
            );

            ratio *= deltaScale;
            this.refresh();
        });

        this.refresh();
    }

    refresh() {
        setElementTransform(this.container, this.transform);
    }

    frameRect(rect, minScale=.25, maxScale=2) {
        const bounds = this.viewport.getBoundingClientRect();

        // find scale that contains all width, all height, and is within limits
        const sx = bounds.width / rect.width;
        const sy = bounds.height / rect.height;
        const scale = clamp(Math.min(sx, sy), minScale, maxScale);

        // find translation that centers the rect in the viewport
        const ex = (1/scale - 1/sx) * bounds.width * .5;
        const ey = (1/scale - 1/sy) * bounds.height * .5;
        const [ox, oy] = [-rect.x + ex, -rect.y + ey];

        this.transform = new DOMMatrix();
        this.transform.scaleSelf(scale, scale);
        this.transform.translateSelf(ox, oy);
        this.refresh();
    }

    mouseEventToViewportTransform(event) {
        const rect = this.viewport.getBoundingClientRect();
        const [sx, sy] = [event.clientX - rect.x, event.clientY - rect.y];
        const matrix = (new DOMMatrixReadOnly()).translate(sx, sy);
        return matrix;
    }

    mouseEventToSceneTransform(event) {
        const mouse = this.mouseEventToViewportTransform(event);
        mouse.preMultiplySelf(this.transform.inverse());
        return mouse;
    }
}

function fakedownToTag(text, fd, tag) {
    const pattern = new RegExp(`${fd}([^${fd}]+)${fd}`, 'g');
    return text.replace(pattern, `<${tag}>$1</${tag}>`);
}

function parseFakedown(text) {
    if (text.startsWith('`'))
        return `<pre>${text.slice(1)}</pre>`;
    text = text.replace(/([^-])--([^-])/g, '$1$2');
    text = fakedownToTag(text, '##\n?', 'h3');
    text = fakedownToTag(text, '~~', 's');
    text = fakedownToTag(text, '__', 'strong');
    text = fakedownToTag(text, '\\*\\*', 'strong');
    text = fakedownToTag(text, '_', 'em');
    text = fakedownToTag(text, '\\*', 'em');
    text = text.replace(/\n/g, '<br>');
    return text;
}

    </script>
    <script id="main.js">const cellWidth = 256;
const cellHeight = 160;

const cellGap = 16;
const cellWidth2 = 112;
const cellHeight2 = 64;

/** @type {PanningScene} */
let scene;

async function start() {
    initui();
    scene = new PanningScene(document.getElementById("scene"));

    const dataElement = ONE("#project-data");
    const player = ONE("body").getAttribute("data-player") === "true";

    /** @type {DominoDataProject} */
    const data = JSON.parse(dataElement.innerHTML);

    await test();
    data.details.id = nanoid();
    dataManager.reset(data);
    invokeAction("global/center-focus");

    console.log("player", player);
    if (player) {
        // data
        boardView.editable = false;
    } else {
        // data

        const search = new URLSearchParams(location.search);
        const loadID = search.get("load");
        if (loadID) {
            const project = await loadProject(loadID);
            dataManager.reset(project);
            invokeAction("global/center-focus");
        }
    }
}

async function loadData() {
    console.log("data");
}

async function loadDataDeferred() {
    console.log("deferred");

    const font = ONE("#font");
    const family = font.getAttribute("data-font-family");

    const css = html("style", { id: "active-font" });
    css.textContent = font.textContent;
    css.setAttribute("data-editor-only", undefined);
    document.head.appendChild(css);

    ONE(":root").style.fontFamily = family;
}

    </script>
  </head>
  <body class="no-select" onload="start()" style="" data-player="true">
    <div id="frame" style="background-color: rgb(106, 107, 116);">
      <div id="scene" style="transform: matrix3d(0.812252, 0, 0, 0, 0, 0.812252, 0, 0, 0, 0, 0.906252, 0, -361.804, 38.711, 0, 1); transition: none 0s ease 0s;" class="">
        <div id="svgs" data-empty=""></div>
        <div id="cards" data-empty=""></div>
      </div>
    </div>
    <div class="toolbar-group icon-bar" id="sidebar-toggle" hidden="">
      <div class="icon" data-action="global-editor/toggle" title="board settings"></div>
    </div>
    <div id="toolbar" data-block-clicks="">
      <div class="toolbar-group icon-bar">
        <div class="icon" id="undo" data-action="global/undo" title="undo"></div>
        <div class="icon disabled" id="redo" data-action="global/redo" title="redo"></div>
        <div class="icon" id="save" data-action="project/save" title="save in browser"></div>
        <div class="icon" data-action="global/view-saves" title="view saved boards"></div>
      </div>
      <div class="toolbar-group icon-bar" data-path="picker" hidden=""><span>click a card to link to</span>
        <div class="icon" data-action="picker/cancel" title="cancel picking"></div>
      </div>
    </div>
    <div id="left-sidebar" data-block-clicks="" data-path="global-editor" hidden="">
      <div class="tab-bar">
        <button data-action="global-editor/close"></button>
        <!--button(data-tab-toggle="sidebar/about" data-tab-default) about-->
        <button data-tab-toggle="sidebar/board" class="active">board</button>
        <button data-tab-toggle="sidebar/styles" class="">styles</button>
        <button data-tab-toggle="sidebar/selection" data-tab-default="" class="">selection</button>
      </div>
      <div class="editor-page" data-tab-body="sidebar/about" hidden=""><h2>about domino</h2>
<p>domino is a tool for collaging fragmented thoughts into a larger idea.
it's essentially a tool for making a particular kind of mindmap and sharing it
as a page on your website or itch.io.</p>
<p>you can find out more about domino on <a href="https://kool.tools/domino/">the release page</a>. the source
code for original releases can be found <a href="https://github.com/Ragzouken/domino2">on github</a>.</p>
<p>i'm <a href="https://twitter.com/ragzouken">mark wonnacott a.k.a candle</a> and i created domino as a
<a href="https://kool.tools/2020/02/26/speculations.html">response to my frustration</a> trying to express myself in Emilie Reed's
writing jams.</p>
<h2>thanks</h2>
<p><strong>Em Reed</strong> for her writing jams--especially <a href="https://itch.io/jam/speculation-jam">Speculation Jam</a>,
<a href="https://itch.io/jam/list-jam">List Jam</a>, <a href="https://itch.io/jam/alternative-ecologies-jam">Alternative Ecologies Jam</a> which have deeply inspired me and
also motivated the creation of this tool.</p>
<p><strong>Max</strong>, <strong>Jazz</strong>, <strong>Ludonaut</strong> for early testing and bug reports.</p>

      </div>
      <div class="sidebar-page" data-tab-body="sidebar/board">
        <div class="sidebar-header">
          <details id="saved-boards" open="">
            <summary> 
              <h2>switch board</h2>
            </summary>
            <div class="sidebar-group">
              <div></div>
              <div class="button-row">
                <button data-action="global/new">new board</button>
                <button data-action="global/import">import board</button>
              </div>
              <select size="12" data-path="global/saves"><option value="5nA3WvcwkscoCzbF4fXAU">vampire house for sale (11/10/2023)</option></select>
              <div class="button-row">
                <button data-action="global/saves/load">load</button>
                <button data-action="global/saves/duplicate">duplicate</button>
                <button data-action="global/saves/delete">delete</button>
              </div>
            </div>
          </details>
        </div>
        <div class="sidebar-panel">
          <h2>title</h2>
          <div class="button-row">
            <input type="text" data-path="global-editor/title">
          </div>
          <h2>initial card focus</h2>
          <p>copy the id of a card selection and paste it here to set where the viewer starts in the board</p>
          <div class="button-row">
            <input type="text" data-path="global-editor/focus">
            <button class="shrink" data-action="global/center-focus"></button>
          </div>
          <h2>background color</h2>
          <div class="button-row">
            <input type="color" data-path="global-editor/style/background-color">
          </div>
          <h2>publish</h2>
          <div class="button-column">
            <button data-action="project/export/html" title="export to standalone webpage"> export to html</button>
            <button data-action="project/publish/neocities" title="export html directly to neocities website"> publish to neocities</button>
            <button id="neocities-view" data-action="project/publish/neocities/view" title="view exported neocities page" disabled=""> view on neocities</button>
          </div>
        </div>
      </div>
      <div class="sidebar-page" data-tab-body="sidebar/styles" hidden="">
        <div class="sidebar-header">
          <div class="button-row">
            <select data-path="global-editor/card-styles/selected"><option value="STYLE-HEADING">heading</option><option value="STYLE-GRID">grid</option><option value="STYLE-TERMINAL">terminal</option><option value="EeMLC4dJM4-iD3bhd2BWk">disabled</option><option value="yrKZvizTDGthzyGX_AA-X">heading 2</option><option value="1HQnPB8fc0zpeLqCCGokQ">context</option><option value="CyZclJHl2fVSpLw53gn1Q">information</option><option value="vc_VZePmvF5KufvjyQGuX">prompt</option><option value="xlPzs0JBKNTPNxweO87oK">default</option></select>
            <button data-action="global-editor/card-style/new">new style</button>
          </div>
        </div>
        <div class="sidebar-panel">
          <h2>name</h2>
          <div class="button-row">
            <input type="text" data-path="global-editor/card-styles/selected/name">
          </div>
          <div id="card-style-fields"><h2>text</h2><div class="settings-grid"><input type="checkbox" class="check"><span>font</span><select><option value="default">default</option><option value="monospace">monospace</option><option value="serif">serif</option><option value="sans-serif">sans-serif</option><option value="cursive">cursive</option></select><input type="checkbox" class="check"><span>size</span><input type="range" min="8" max="64"><input type="checkbox" class="check"><span>color</span><input type="color"><input type="checkbox" class="check"><span>center</span></div><h2>card</h2><div class="settings-grid"><input type="checkbox" class="check"><span>color</span><input type="color"><input type="range" min="0" max="255"></div></div>
          <h2>custom css</h2>
          <textarea data-path="global-editor/card-styles/selected/custom-css"></textarea>
          <div class="button-row">
            <button data-action="global-editor/card-style/selected/duplicate">duplicate style</button>
            <button data-action="global-editor/card-style/selected/delete" data-path="global-editor/card-style/selected/delete">delete style</button>
          </div>
        </div>
      </div>
      <div class="sidebar-page" data-tab-body="sidebar/selection" hidden="">
        <div hidden="">
          <button data-tab-toggle="sidebar/selection/none" data-tab-default="" class=""></button>
          <button data-tab-toggle="sidebar/selection/cards" class="active"></button>
          <button data-tab-toggle="sidebar/selection/group"></button>
          <button data-tab-toggle="sidebar/selection/link"></button>
        </div>
        <div class="sidebar-page" data-tab-body="sidebar/selection/none" hidden="">
          <div class="sidebar-header">nothing selected</div>
        </div>
        <div class="sidebar-page" data-tab-body="sidebar/selection/cards">
          <div class="sidebar-header">
            <div><span data-path="selection/prompt">1 cards selected</span></div>
            <div class="button-row">
              <button data-action="selection/cancel">deselect</button>
              <button data-action="selection/copy-id">copy id</button>
              <button data-action="selection/link" data-path="selection/link">link</button>
              <button data-action="selection/group" data-path="selection/group" hidden="">group</button>
              <button data-action="selection/delete">delete</button>
            </div>
          </div>
          <div class="sidebar-panel">
            <div class="sidebar-group" data-path="card-editor/text">
              <h2>text</h2>
              <div class="button-row">
                <button data-action="card-editor/text/bold">bold</button>
                <button data-action="card-editor/text/italic">italic</button>
                <button data-action="card-editor/text/strike">strike</button>
                <button data-action="card-editor/text/header">header</button>
              </div>
              <textarea data-path="card-editor/text/value" spellcheck="true"></textarea>
            </div>
            <div class="sidebar-group" data-path="card-editor/icons">
              <h2>icons</h2>
              <div id="card-editor-icons">
                <input class="icon-select" data-path="card-editor/icons/1/icon" type="text">
                <input class="icon-action" data-path="card-editor/icons/1/action" type="text">
                <input class="icon-select" data-path="card-editor/icons/2/icon" type="text">
                <input class="icon-action" data-path="card-editor/icons/2/action" type="text">
                <input class="icon-select" data-path="card-editor/icons/3/icon" type="text">
                <input class="icon-action" data-path="card-editor/icons/3/action" type="text">
                <input class="icon-select" data-path="card-editor/icons/4/icon" type="text">
                <input class="icon-action" data-path="card-editor/icons/4/action" type="text">
              </div>
            </div>
            <div class="sidebar-group" data-path="card-editor/style">
              <h2>style</h2>
              <select data-path="card-editor/styles" size="3"><option value="default">default</option><option value="STYLE-HEADING">heading</option><option value="STYLE-GRID">grid</option><option value="STYLE-TERMINAL">terminal</option><option value="EeMLC4dJM4-iD3bhd2BWk">disabled</option><option value="yrKZvizTDGthzyGX_AA-X">heading 2</option><option value="1HQnPB8fc0zpeLqCCGokQ">context</option><option value="CyZclJHl2fVSpLw53gn1Q">information</option><option value="vc_VZePmvF5KufvjyQGuX">prompt</option><option value="xlPzs0JBKNTPNxweO87oK">default</option></select>
              <div class="button-row">
                <button data-action="card-editor/styles/edit">edit</button>
              </div>
            </div>
            <div class="sidebar-group" data-path="card-editor/image">
              <h2>image</h2>
              <div class="button-row">
                <button data-action="card-editor/image/upload">upload image</button>
                <button data-action="card-editor/image/remove">remove image</button>
              </div>
              <textarea data-path="card-editor/image/alt" placeholder="alt text" spellcheck="true"></textarea>
            </div>
          </div>
        </div>
        <div class="sidebar-page" data-tab-body="sidebar/selection/group" hidden="">
          <div class="sidebar-header">
            <div data-path="group/prompt">1 group selected</div>
            <div class="button-row">
              <button data-action="group/deselect">deselect</button>
              <button data-action="group/select">select cards</button>
              <button data-action="group/delete">ungroup</button>
            </div>
          </div>
          <div class="sidebar-panel">
            <h2>color</h2>
            <input type="color" data-path="group/color">
          </div>
        </div>
        <div class="sidebar-page" data-tab-body="sidebar/selection/link" hidden="">
          <div class="sidebar-header">
            <div data-path="link/prompt">1 link selected</div>
            <div class="button-row">
              <button data-action="link/deselect">deselect</button>
              <button data-action="link/select">select cards</button>
              <button data-action="link/delete">unlink</button>
            </div>
          </div>
          <div class="sidebar-panel">
            <h2>color</h2>
            <input type="color" data-path="link/color">
          </div>
        </div>
      </div>
    </div>
    <script id="project-data" type="text/json">{"details":{"id":"5nA3WvcwkscoCzbF4fXAU","title":"vampire house for sale","name":"project","focus":"#Sto2yT3XoIAKqBSx7RTMQ"},"cards":[{"id":"r0Y8icCSYKaFkSYrQSURp","position":{"x":1024,"y":240},"size":{"x":6,"y":5},"text":"you are dracula's childe\ndracula is trying to sell the house so you can move to the moon\nyour three moms are already there\nyou have to lead realtors through the house to speak with dracula\nthe house is troublesome & eats all the realtors\nspeaking to the house consoles both you and her\nyou can promise you'll be back or\nyou can encourage her that she'll have a new family soon\nyou can help her kill the realtors\nif you kill all the realtors the game ends & you don't go to the moon\nif you soothe the house you can lead a realtor safely to dracula\ndracula sells the castle and the game ends on the moon with moms","icons":[{"icon":"","action":""},{"icon":"","action":""},{"icon":"","action":""},{"icon":"","action":""}],"alttext":"","style":"xlPzs0JBKNTPNxweO87oK"},{"id":"Sto2yT3XoIAKqBSx7RTMQ","position":{"x":1024,"y":80},"size":{"x":6,"y":2},"text":"\n Castle for Sale \n","icons":[{"icon":"","action":""},{"icon":"","action":""},{"icon":"","action":""},{"icon":"","action":""}],"alttext":"","style":"yrKZvizTDGthzyGX_AA-X"}],"groups":[],"links":[],"cardStyles":[{"id":"STYLE-HEADING","name":"heading","properties":{"text-size":"30px","text-center":true,"card-color":"#00000040","custom-css":".card-body { align-items: center; font-weight: bold; } .card-root { --card-edge-color: rgba(0, 0, 0, 25%); }"}},{"id":"STYLE-GRID","name":"grid","properties":{"custom-css":".card-body { line-height: 1.35em; background-image: linear-gradient(gainsboro 1px, transparent 1px), linear-gradient(90deg, gainsboro 1px, transparent 1px); background-size: 1.3em 1.3em; background-position: .75em .75em; }"}},{"id":"STYLE-TERMINAL","name":"terminal","properties":{"text-font":"monospace","text-color":"#00ff00ff","card-color":"#000000FF"}},{"id":"EeMLC4dJM4-iD3bhd2BWk","name":"disabled","properties":{"text-color":"#7d7d7dff","card-color":"#ffffff7c"}},{"id":"yrKZvizTDGthzyGX_AA-X","name":"heading 2","properties":{"text-size":"40px","card-color":"#0000008c","text-color":"#b73645ff","text-font":"serif","custom-css":".card-text {\nfont-variant: small-caps;\n}","text-center":"true"}},{"id":"1HQnPB8fc0zpeLqCCGokQ","name":"context","properties":{"card-color":"#e5efd2ff","custom-css":""}},{"id":"CyZclJHl2fVSpLw53gn1Q","name":"information","properties":{"card-color":"#d2deefff","custom-css":""}},{"id":"vc_VZePmvF5KufvjyQGuX","name":"prompt","properties":{"card-color":"#efd6d2ff","custom-css":""}},{"id":"xlPzs0JBKNTPNxweO87oK","name":"default","properties":{"text-color":"#434343ff","card-color":"#ffffff68","text-size":"19px"}}],"boardStyle":{"background-color":"#6a6b74"}}</script>
    <script>loadData();</script>
    <script id="project-data-deferred" type="text/json">{}</script>
    <script id="font" type="text/css" data-font-family="Lora">@font-face {
    font-family: 'Lora';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url(data:font/woff2;base64,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) format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

    </script>
    <script>loadDataDeferred();</script>
  
</body></html>